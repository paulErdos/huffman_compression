<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>A Tutorial for GNU Smalltalk</title>
</head>

<body>
<h1>A Tutorial for GNU Smalltalk</h1>

<CENTER>
                      <EM>Andrew Valencia</EM><br>
                    Valencia Consulting
</CENTER>

<A NAME="Overview"></A>
<H2>Overview</H2>

<A NAME="Whatthismanualpresents"></A>
<H2>What this manual presents</H2>
<P>
     This  document  provides a tutorial introduction to the
Smalltalk language in general, and the GNU Smalltalk  implementation  in
particular.   It  does not provide exhaustive 
coverage of every feature of the language and its libraries;
instead,  it  attempts to introduce a critical mass of ideas
and techniques to get the Smalltalk  novice  moving  in  the
right direction.

<A NAME="Whothismanualiswrittenfor"></A>
<H2>Who this manual is written for</H2>
<P>
     This manual assumes that the reader is acquainted with the basics of
computer science, and has reasonable proficiency with a procedural language
such as <EM>C</EM>. It also assumes that the reader is already familiar
with the usual janitorial tasks associated with programming - editing,
moving files, and so forth.

<A NAME="1.Gettingstarted"></A>
<H2>1.  Getting started</H2>

<A NAME="1.1.StartingupSmalltalk"></A>
<H3>1.1.  Starting up Smalltalk</H3>
<P>
     Assuming that GNU Smalltalk has been installed on  your
system, starting it is as simple as:
<PRE>
     % mst
</PRE>
the system loads in Smalltalk, and displays a startup banner
like:
<PRE>
     Smalltalk 1.1.1 Ready

     st&gt;
</PRE>
You are now ready to try your hand  at  Smalltalk!   By  the
way, when you're ready to quit, you exit Smalltalk by typing
control-D on an empty line.

<A NAME="1.2.Sayinghello"></A>
<H3>1.2.  Saying hello</H3>
<P>
     An initial exercise is to make Smalltalk say "<CODE>hello</CODE>" to
you.   Type in the following line ("<CODE>printNl</CODE>" is a upper case
N and a lower case L):
<PRE>
      'Hello, world' printNl !
</PRE>
The system then prints back 'Hello, world' to you.<A
HREF="smalltalk-tutorial.html#note1">[1]</A><A name="ref1"></A></A> 


<A NAME="1.3.Whatactuallyhappened"></A>
<H3>1.3.  What actually happened</H3>
<P>
     The  front-line  Smalltalk interpreter gathers all text
until a '!'  character  and  executes  it.   So  the  actual
Smalltalk code executed was:
<PRE>
      'Hello, world' printNl
</PRE>
This  code  does two things.  First, it creates an object of
type "<CODE>String</CODE>" which contains the characters "<CODE>Hello,
world</CODE>". 
Second,  it sends the message named "<CODE>printNl</CODE>" to the object.
When the object is done processing the message, the code  is
done and we get our prompt back.
<P>
     You'll  notice that we didn't say anything about printing the string,
even though that's in  fact  what  happened. 
This  was  very much on purpose - the code we typed in <EM>doesn't
know anything about printing strings</EM>.  It knew how to get  a
string  object,  and  it  knew how to send a message to that
object.  That's the end of the story for the code we  wrote.
But  for  fun,  let's  take a look at what happened when the
string object received the "<CODE>printNl</CODE>" message.

<A NAME="1.4.WhatastringdoeswithaprintNlmessage"></A>
<H3>1.4.  What a string does with a "<CODE>printNl</CODE>" message</H3>
<P>
     The string object containing "<CODE>Hello,  world</CODE>"  was  sent
the message "<CODE>printNl</CODE>".  It then goes to a table<A
HREF="smalltalk-tutorial.html#note2">[2]</A><A name="ref2"></A></A> which lists 
the  messages  which  strings  can receive, and what code to
execute.  It  finds  that  there  is  indeed  an  entry  for
"<CODE>printNl</CODE>"  and runs this code.  This code then walks through
its  characters, printing each of them out to the terminal.<A
HREF="smalltalk-tutorial.html#note3">[3]</A><A name="ref3"></A></A> 
The central point  is  that  an  object  is  entirely  selfcontained;  only
the  object  knew how to print itself out. 
When we want an object to  print  out,  we  ask  the  object
itself to do the printing.

<A NAME="1.5.Doingmath"></A>
<H3>1.5.  Doing math</H3>
<P>
     A similar piece of code prints numbers:
<PRE>
     1234 printNl !
</PRE>
Notice  how  we used the same message, but have sent it to a
new type of object - an integer (from class  "<CODE>Integer</CODE>").   The
way  in  which  an integer is printed is much different from
the way a string is printed on the inside,  but  because  we
are  just  sending  a message, we do not have to be aware of
this.  We tell it to "<CODE>printNl</CODE>", and it prints itself out.
<P>
     As a <EM>user</EM> of an object, we can thus usually send a particular
message and expect basically the same kind of behavior, regardless of
object's internal structure (for instance, we have seen that sending
"<CODE>printNl</CODE>" to an object makes the object print itself). In
later chapters we will see a wide range of types of objects. Yet all of
them can be printed out the same way - with "<CODE>printNl</CODE>".
<P>
     White space is ignored, except as it  separates  words.
This example could also have looked like:
<PRE>
                1234
      printNl          !
</PRE>
<P>
     An integer can be sent a number of messages in addition
to just printing itself.  An important set of  messages  for
integers are the ones which do math:



<PRE>
     (9 + 7) printNl !
</PRE>
Answers  (correctly!)  the  value  16.  The way that it does
this, however, is a significant departure from a  procedural
language.

<A NAME="1.6.MathinSmalltalk"></A>
<H3>1.6.  Math in Smalltalk</H3>
<P>
     In this case, what happened was that the object "<CODE>9</CODE>" (an
<CODE>Integer</CODE>), received a "<CODE>+</CODE>" message with  an
argument  of  "<CODE>7</CODE>" 
(also an <CODE>Integer</CODE>).  The "<CODE>+</CODE>" message for integers
then caused 
Smalltalk to create a new object "<CODE>16</CODE>" and return it  as  the
resultant  object.   This  "<CODE>16</CODE>"  object  was  then given the
"<CODE>printNl</CODE>" message, and printed "<CODE>16</CODE>" on the
terminal. 
<P>
     Thus, math is not a special case in  Smalltalk;  it  is
done  exactly  like everything else - by creating objects, and
sending them messages.  This may seem odd to  the  Smalltalk
novice,  but  this  regularity turns out to be quite a boon - 
once you've mastered just a few paradigms, all of  the  language  "falls
into  place."   Before  you go on to the next 
chapter, make sure you try math involving  "<CODE>*</CODE>"
(multiplication),  "<CODE>-</CODE>"  (subtraction),  and "<CODE>/</CODE>"
(division) also.  These 
examples should get you started:
<PRE>
     (8 * (4 / 2)) printNl !
     (8 - (4 + 1)) printNl !
     (5 + 4) printNl !
     (2/3 + 7) printNl !
     (2 + 3 * 4) printNl !
     (2 + (3 * 4)) printNl !
</PRE>


<A NAME="2.UsingsomeoftheSmalltalkclasses"></A>
<H2>2.  Using some of the Smalltalk classes</H2>
<P>
     This chapter has examples which need a  place  to  hold
the  objects they create.  The following line creates such a
place; for now, treat it as magic.  At the end of the  chapter we will
revisit it with an explanation.  Type in: 
<PRE>
     Smalltalk at: #x put: 0 !
</PRE>
Now let's create some new objects.

<A NAME="2.1.AnarrayinSmalltalk"></A>
<H3>2.1.  An array in Smalltalk</H3>
<P>
     An  array  in  Smalltalk  is similar to an array in any
other language, although the syntax  may  seem  peculiar  at
first.  To create an array with room for 20 elements, do:
<PRE>
     x := Array new: 20 !
</PRE>
The  "<CODE>Array new: 20</CODE>" creates the array; the "<CODE>x
:=</CODE>" part connects the name "<CODE>x</CODE>" with the object.  Until
you assign  something  else  to "<CODE>x</CODE>", you can refer to this
array by the name 
"<CODE>x</CODE>".
<P>
     Changing elements of the array is <EM>not</EM>  done  using  the
"<CODE>:=</CODE>"  operator;  this operator is used only to bind names to
objects.   In  fact,  you  never  modify  data   structures;
instead,  you send a message to the object, and it will modify itself.  For
instance: 
<PRE>
     (x at: 1) printNl !
</PRE>
which prints:
<PRE>
     nil
</PRE>
The slots of an array are initially set to "nothing"  (which
Smalltalk  calls  "<CODE>nil</CODE>").   Let's  set the first slot to the
number 99:
<PRE>
     x at: 1 put: 99 !
</PRE>
and now make sure the 99 is actually there:
<PRE>
     (x at: 1) printNl !
</PRE>
which then prints out:
<PRE>
     99
<>
<HR><H3>Transfer interrupted!</H3>
pulate an array.   They  also
show  the  standard  way  in which messages are passed arguments.  In most
cases, if a message takes an  argument,  its 
name  will  end with "<CODE>:</CODE>"<A HREF="smalltalk-tutorial.html#note4">[4]</A><A
name="ref4"></A></A>. So when we said "<CODE>x at: 1</CODE>" we were 
sending a message to whatever object was currently bound  to
"<CODE>x</CODE>"  with  an  argument of 1.  For an array, this results in
the first slot of the array being returned.
<P>
     The second operation, "<CODE>x at: 1 put: 99</CODE>"  is  a  message
with  <EM>two</EM> arguments.  It tells the array to place the second
argument (99) in the slot specified by the first (1).  Thus,
when  we  re-examine  the  first  slot,  it  does indeed now
contain 99.
<P>
     There is a shorthand for describing  the  messages  you
send  to  objects.  You just run the message names together.
So we would say that our array accepts both  the  "<CODE>at:</CODE>"  and
"<CODE>at:put:</CODE>" messages.
<P>
     There  is  quite a bit of sanity checking built into an
array.  The request
<PRE>
     6 at: 1
</PRE>
fails with an error; 6 is an integer, and can't be  indexed.
Further,
<PRE>
     x at: 21
</PRE>
fails  with  an error, because the array we created only has
room  for  20 objects<A HREF="smalltalk-tutorial.html#note5">[5]</A><A name="ref5"></A></A>.
Finally, note that the object stored 
in an array is just like any other  object,  so  we  can  do
things like:
<PRE>
     ((x at: 1) + 1) printNl !
</PRE>
which  (assuming  you've  been  typing in the examples) will
print 100.

<A NAME="2.2.AsetinSmalltalk"></A>
<H3>2.2.  A set in Smalltalk</H3>
<P>
     We're done with the array we've been  using,  so  we'll
assign  something  new  to  our  "<CODE>x</CODE>" variable.  Note that we
don't need to do anything special about  the  old  array - the
fact  that nobody is using it any more will be automatically
detected, and the memory reclaimed<A HREF="smalltalk-tutorial.html#note6">[6]</A><A
name="ref6"></A></A>.  So,  to  get  our  new 
object, simply do:
<PRE>
     x := Set new !
</PRE>
Which creates an empty set.  To view its contents, do:
<PRE>
     x printNl !
</PRE>
the  kind of object is printed out (i.e., Set), and then the
members are listed within parenthesis.  Since it's empty, we
see:
<PRE>
     Set ()
</PRE>
Now  let's toss some stuff into it.  We'll add the numbers 5
and 7, plus the string 'foo'.  We <EM>could</EM> type:

<PRE>
     x add: 5 !
     x add: 7 !
     x add: 'foo' !
</PRE>
But let's save a little typing by using a  Smalltalk  shorthand:
<PRE>
     x add: 5; add: 7; add: 'foo' !
</PRE>
This line does exactly what the previous example's three lines did. The
trick is that the semicolon operator causes the message to be sent to the
same object as the last message sent. So saying "<CODE>; add: 7</CODE>" is
the same as saying "<CODE>x add: 7</CODE>", because "<CODE>x</CODE>" was
the last thing a message was sent to. This may not seem like such a big
savings, but compare the ease when your variable is named
"<CODE>aVeryLongVariableName</CODE>" instead of just "<CODE>x</CODE>"!
We'll revisit some other occasions where "<CODE>;</CODE>" saves you
trouble, but for now let's continue with our set. Type either version of
the example, and make sure that we've added 5, 7, and "<CODE>foo</CODE>":
<PRE>
     x printNl !
</PRE>
we'll see that it now contains our data:
<PRE>
     Set (5 'foo' 7)
</PRE>
What if we add something twice?  No problem - it just stays in
the set.  So a set is like a big  checklist - either  it's  in
there, or it isn't.  To wit:
<PRE>
     x add:5; add: 5; add: 5; add: 5 !
     x printNl !
</PRE>
We've  added  "<CODE>5</CODE>" several times, but when we printed our set
back out, we just see:
<PRE>
     Set (5 'foo' 7)
</PRE>
<P>
     What you put into a set with "<CODE>add:</CODE>", you can  take  out
with "<CODE>remove:</CODE>".  Try:
<PRE>
     x remove: 5 !
     x printNl !
</PRE>
The set now prints as:
<PRE>
     Set ('foo' 7)
</PRE>
The "<CODE>5</CODE>" is indeed gone from the set.
<P>
     We'll  finish  up  with one more of the many things you
can do with a set -  checking for membership.  Try:
<PRE>
     (x includes: 7) printNl !
     (x includes: 5) printNl !
</PRE>
From which we see that x does indeed contain 7, but not 5. Notice that the
answer is printed as "<CODE>true</CODE>" or "<CODE>false</CODE>". Once
again, the thing returned is an object - in this case, an object known as a
boolean. We'll look at the use of booleans later, but for now we'll just
say that booleans are nothing more than objects which can only either be
true or false - nothing else. So they're very useful for answers to yes or
no questions, like the ones we just posed. Let's take a look at just one
more kind of data structure:

<A NAME="2.3.Dictionaries"></A>
<H3>2.3.  Dictionaries</H3>
<P>
     A dictionary is a special kind of collection. With a regular array,
you must index it with integers. With dictionaries, you can index it with
<EM>any</EM> object at all. Dictionaries thus provide a very powerful way
of correlating


one piece of information to another.  Their only downside is
that  they  are  somewhat less efficient than simple arrays.
Try the following:
<PRE>
     x := Dictionary new.
     x at: 'One' put: 1 !
     x at: 'Two' put: 2 !
     x at: 1 put: 'One' !
     x at: 2 put: 'Two' !
</PRE>
This fills our dictionary in with some data.   The  data  is
actually  stored  in pairs of key and value (the key is what
you give to <CODE>at:</CODE> - it specifies a slot; the value  is  what  is
actually  stored  at that slot).  Notice how we were able to
specify not only integers but also strings as both  the  key
and  the  value.   In fact, we can use any kind of object we
want as either - the dictionary doesn't care.
<P>
     Now we can map each key to a value:
<PRE>
     (x at: 1) printNl !
     (x at: 'Two') printNl !
</PRE>
which prints respectively:
<PRE>
      'One'
      2
</PRE>
We can also ask a dictionary to print itself:
<PRE>
     x printNl !
</PRE>
which prints:
<PRE>
     Dictionary (1,'One' 2,'Two' 'One',1 'Two',2 )
</PRE>
where the first member of each pair is the key, and the second the value.

<A NAME="2.4.Smalltalkdictionary"></A>
<H3>2.4.  Smalltalk dictionary</H3>
<P>
     If  you'll  remember from the beginning of the chapter,
we started out by saying:
<PRE>
     Smalltalk at: #x put: 0 !
</PRE>
This code should look familiar - the <CODE>at:put:</CODE> message is how
we've been storing information in our own arrays and dictionaries. In a
Smalltalk environment the name "<CODE>Smalltalk</CODE>" has been preset to
point to a dictionary<A HREF="smalltalk-tutorial.html#note7">[7]</A><A name="ref7"></A></A> which
both you <EM>and</EM> Smalltalk can use. To see how this sharing works,
we'll first try to use a variable which Smalltalk doesn't know about:
<PRE>
     y := 0 !
</PRE>
Smalltalk complains because  "<CODE>y</CODE>"  is  an  unknown  variable.
Using our knowledge of dictionaries, and taking advantage of
our access to Smalltalk's dictionary, we  can  add  it  ourselves:

<PRE>
     Smalltalk at: #y put: 0 !
</PRE>
The only mystery left is why we're using "<CODE>#y</CODE>" instead of our
usual quoted string. This is one of those simple questions whose answer
runs surprisingly deep. The quick answer is that "<CODE>#y</CODE>" and
"<CODE>'y'</CODE>" are pretty much the same, except that the former will
always be the same object each time you use it, whereas the latter can be a
new string each time you do so<A HREF="smalltalk-tutorial.html#note8">[8]</A><A
name="ref8"></A></A>.
<P>
     Now that we've added "<CODE>y</CODE>" to Smalltalk's dictionary,  we
try again:
<PRE>
     y := 1 !
</PRE>
It  works!  Because you've added an entry for "<CODE>y</CODE>", Smalltalk
is now perfectly happy to let you use this new variable.
<P>
     If you have some spare time,  you  can  print  out  the
<EM>entire</EM> Smalltalk dictionary with:
<PRE>
     Smalltalk printNl !
</PRE>
As you might suspect, this will print out quite a large list
of names!  If you get tired of watching Smalltalk  grind  it
out,  use  your  interrupt key (control-C, usually) to bring
Smalltalk back to interactive mode.

<A NAME="2.5.Closingthoughts"></A>
<H3>2.5.  Closing thoughts</H3>
<P>
     You've seen how Smalltalk provides you with  some  very
powerful  data  structures.   You've also seen how Smalltalk
itself uses these same facilities to implement the language.
But  this  is  only the tip of the iceberg - Smalltalk is much
more than a collection of "neat" facilities to use.
<P>
     The objects and methods which are automatically  available  are  only
the beginning of the foundation on which you build your programs -
Smalltalk allows you to add your own objects and methods into the system,
and then use them along with everything else. The art of programming in
Smalltalk is the art of looking at your problems in terms of objects, using
the existing object types to good effect, and enhancing Smalltalk with new
types of objects. Now that you've been exposed to the basics of Smalltalk
manipulation, we can begin to look at this object-oriented technique of
programming.

<A NAME="3.TheSmalltalkclasshierarchy"></A>
<H2>3.  The Smalltalk class hierarchy</H2>
<P>
     When programming in Smalltalk, you  sometimes  need  to
create  new  kinds  of objects, and define what various messages will do to
these objects.  In the next chapter we will 
create some new classes, but first we need to understand how
Smalltalk organizes  the  types  and  objects  it  contains.
Because this is a pure "concept" chapter, without any actual
Smalltalk code to run, we will keep  it  short  and  to  the
point.

<A NAME="3.1.ClassObject"></A>
<H3>3.1.  Class Object</H3>
<P>
     Smalltalk  organizes all of its classes as a tree hierarchy.  At the
     very top of this hierarchy is class "<CODE>Object</CODE>". 
Following somewhere below it are more specific classes, such
as the ones we've worked with - strings, integers, arrays, and
so forth.  They are grouped together based on their similarities - for
instance, types of objects which may  be  compared 
as  greater or less than each other fall under a class known
as "<CODE>Magnitude</CODE>".
<P>
     One of the first tasks when creating a new object is to
figure  out  where  within this hierarchy your object falls.
Coming up with an answer to this problem is at least as much
art as science, and there are no hard-and-fast rules to nail
it down.  We'll take a look at three  kinds  of  objects  to
give you a feel for how this organization matters.

<A NAME="3.2.Animals"></A>
<H3>3.2.  Animals</H3>
<P>
     Imagine that we have three kinds of objects, representing
     "<CODE>Animals</CODE>", "<CODE>Parrots</CODE>", and
     "<CODE>Pigs</CODE>".  Our messages will  be 
"<CODE>eat</CODE>",  "<CODE>sing</CODE>",  and  "<CODE>snort</CODE>".   Our
first pass at inserting 
these objects into the Smalltalk  hierarchy  would  organize
them like:
<PRE>
     Object
          Animals
          Parrots
          Pigs
</PRE>
This  means  that  <CODE>Animals</CODE>, <CODE>Parrots</CODE>, and
<CODE>Pigs</CODE> are all direct 
descendants of "<CODE>Object</CODE>", and are  not  descendants  of  each
other.
<P>
     Now  we  must  define  how each animal responds to each
kind of message.
<PRE>
          Animals
               eat--Say "I have now eaten"
               sing--Error
               snort--Error
          Parrots
               eat--Say "I have now eaten"
               sing--Say "Tweet"
               snort--Error
          Pigs
               eat--Say "I have now eaten"
               sing--Error
               snort--Say "Oink"
</PRE>
Notice how we kept having to indicate an action  for  "<CODE>eat</CODE>".


An  experienced  object designer would immediately recognize
this as a clue that we haven't set  up  our  hierarchy  correctly.  Let's
try a different organization: 
<PRE>
          Animals
               Parrots
                    Pigs
</PRE>
That is, <CODE>Parrots</CODE> inherit from <CODE>Animals</CODE>, and
<CODE>Pigs</CODE> from <CODE>Parrots</CODE>. Now <CODE>Parrots</CODE>
inherit all of the actions from <CODE>Animals</CODE>, and <CODE>Pigs</CODE>
from both <CODE>Parrots</CODE> <EM>and</EM> <CODE>Animals</CODE>. Because
of this inheritance, we may now define a new set of actions which spares us
the redundancy of the previous set:
<PRE>
          Animals
               eat--Say "I have now eaten"
               sing--Error
               snort--Error
          Parrots
               sing--Say "Tweet"
          Pigs
               snort--Say "Oink"
</PRE>
Because  <CODE>Parrots</CODE> and <CODE>Pigs</CODE> both inherit from
<CODE>Animals</CODE>, we have 
only had to define the "<CODE>eat</CODE>" action once.  However, we  have
made  one  mistake  in  our class setup - what happens when we
tell a <CODE>Pig</CODE> to "<CODE>sing</CODE>"?  It says
"<CODE>Tweet</CODE>", because we have  put 
<CODE>Pigs</CODE>  as an inheritor of <CODE>Parrots</CODE>.  Let's try one
final organization: 
<PRE>
          Animals
               Parrots
               Pigs
</PRE>
Now <CODE>Parrots</CODE> and <CODE>Pigs</CODE> inherit from
<CODE>Animals</CODE>, but not from each 
other.  Let's also define one final pithy set of actions:
<PRE>
          Animals
               eat--Say "I have eaten"
          Parrots
               sing--Say "Tweet"
          Pigs
               snort--Say "Oink"
</PRE>
The change is just to leave out messages which are inappropriate. If
Smalltalk detects that a message is not known by an object or any of its
ancestors, it will automatically give an error - so you don't have to do
this sort of thing yourself. Notice that now sending "<CODE>sing</CODE>" to
a <CODE>Pig</CODE> does indeed <EM>not</EM> say "<CODE>Tweet</CODE>" - it
will cause a Smalltalk error instead.

<A NAME="3.3.Thebottomlineoftheclasshierarchy"></A>
<H3>3.3.  The bottom line of the class hierarchy</H3>
<P>
     The goal of the class hierarchy is to allow you to organize objects
into a relationship which allows a particular object to <EM>inherit</EM>
the code of its ancestors. Once you have identified an effective
organization of types, you should find that a particular technique need
only be implemented once, then inherited by the children below. This keeps
your code smaller, and allows you to fix a bug in a particular algorithm in
only once place - then have all users of it just inherit the fix.


<P>
     You  will find your decisions for adding objects change
as you gain experience.  As you become  more  familiar  with
the  existing  set  of objects and messages, your selections
will increasingly "fit in" with the existing ones.  But even
a  Smalltalk "pro" stops and thinks carefully at this stage - 
so don't be daunted if your first choices seem difficult and
error-prone.


<A NAME="4.Creatinganewclassofobjects"></A>
<H2>4.  Creating a new class of objects</H2>
<P>
     With  the  basic  techniques presented in the preceding
chapters, we're ready do our first real  Smalltalk  program.
In this chapter we will construct three new types of objects
(known as  "classes"),  using  the  Smalltalk  technique  of
<EM>inheritance</EM>  to tie the classes together, create new objects
belonging to these classes (known as creating  <EM>instances</EM>  of
the class), and send messages to these objects.
<P>
     We'll exercise all this by implementing a toy home-finance accounting
system. We will keep track of our overall cash, and will have special
handling for our checking and savings accounts. From this point on, we will
be defining classes which will be used in future chapters. Since you will
probably not be running this whole tutorial in one Smalltalk session, it
would be nice to save off the state of Smalltalk and resume it without
having to retype all the previous examples. To save the current state of
GNU Smalltalk, type:
<PRE>
     Smalltalk snapshot: 'myimage.img' !
</PRE>
and from your shell, to later restart  Smalltalk  from  this
"snapshot":
<PRE>
     % mst -I myimage.img
</PRE>
Such  a  snapshot  currently takes a little over 300K bytes,
and contains all variables,  classes,  and  definitions  you
have added.

<A NAME="4.1.Creatinganewclass"></A>
<H3>4.1.  Creating a new class</H3>
<P>
     Guess  how you create a new class?  This should be getting monotonous
     by now - by sending a message  to  an  object. 
The way we create our first "custom" class is by sending the
following message:
<PRE>
     Object subclass: #Account
          instanceVariableNames: 'balance'
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !
</PRE>
Quite a mouthful, isn't it?  Most people end up  customizing
their editor to pop this up at a push of a button.  But conceptually, it
isn't really that bad.  The Smalltalk variable 
"<CODE>Object</CODE>"  is  bound to the grand-daddy of all classes on the
system.  What we're doing here is telling the "<CODE>Object</CODE>" class
that  we  want  to  add to it a subclass known as "<CODE>Account</CODE>".
The  other  parts  of  the  message  can  be  ignored,   but
"<CODE>instanceVariableNames: 'balance'</CODE>" tells it that each object
in  this  subclass  will  have  a  hidden   variable   named
"<CODE>balance</CODE>"<A HREF="smalltalk-tutorial.html#note9">[9]</A><A name="ref9"></A></A>.

<A NAME="4.2.Documentingtheclass"></A>
<H3>4.2.  Documenting the class</H3>
<P>
     The next step is to associate a  description  with  the
class.  You do this by sending a message to the new class:
<PRE>
     Account comment: 'I represent a place to deposit and withdraw money' !
</PRE>
A  description is associated with <EM>every</EM> Smalltalk class, and
it's considered good form to add a description to  each  new
class you define.  To get the description for a given class:
<PRE>
     (Account comment) printNl !
</PRE>
And your string is printed back to you.  Try this with class
Integer, too:
<PRE>
     (Integer comment) printNl !
</PRE>

<A NAME="4.3.Definingamethodfortheclass"></A>
<H3>4.3.  Defining a method for the class</H3>
<P>
     We  have  created a class, but it isn't ready to do any
work for us - we have to define some messages which the  class
can process first.  We'll start at the beginning by defining
methods for instance creation:
<PRE>
     !Account class methodsFor: 'instance creation'!

     new
          | r |

          r := super new.
          r init.
          ^r
     !!
</PRE>
Again, programming your editor to do this is recommended. The important
points about this are "<CODE>Account class</CODE>", which means that we are
defining messages which are to be sent to the <CODE>Account</CODE> class
itself. "<CODE>methodsFor: 'instance creation'</CODE>" is more
documentation support; it says that all of the methods defined will be to
support creating objects of type <CODE>Account</CODE>. Finally, the text
starting with "<CODE>new</CODE>" and ending with "<CODE>!!</CODE>" defined
what action to take for the message "<CODE>new</CODE>". When you enter this
definition, GNU Smalltalk will simply give you another prompt. You method
has been compiled in and is ready for use. GNU Smalltalk is pretty quiet on
successful method definitions - but you'll get plenty of error messages if
there's a problem!
<P>
     This is also the first example where we've had  to  use
more  than  one  statement, and thus a good place to present
the statement separator - the ".".  Like Pascal, and unlike C,
statements  are  <EM>separated</EM> rather than terminated.  Thus you
need only use the "." when you have finished  one  statement
and  are  starting another.  This is why our last statement,
"<CODE>^r</CODE>", does not have a "." following.

<P>
     The best way to describe how this method  works  is  to
step through it.  Imagine we sent a message to the new class
Account with the command line:
<PRE>
     Account new !
</PRE>
<P>
     "<CODE>Account</CODE>" receives the message "<CODE>new</CODE>" and
looks up how to process this message. It finds our new definition, and
starts running it. The first line, "<CODE>| r |</CODE>", creates a
<EM>local variable</EM> named "<CODE>r</CODE>" which can be used as a
placeholder for the objects we create. "<CODE>r</CODE>" will go away as
soon as the message is done being processed.
<P>
     The  first  real step is to actually create the object.
The line "<CODE>r := super new</CODE>" does this using a fancy trick. The
word "<CODE>super</CODE>" stands for the same object that the message
"<CODE>new</CODE>" was originally sent to (remember - it's
"<CODE>Account</CODE>"), except that when Smalltalk goes to search for the
methods, he starts one level <EM>higher</EM> up in the hierarchy than the
current level. So for a method in the <CODE>Account</CODE> class, this is
the <CODE>Object</CODE> class (because the class <CODE>Account</CODE>
inherits from is <CODE>Object</CODE> - go back and look at how we created
the <CODE>Account</CODE> class), and the <CODE>Object</CODE> class' methods
then execute some code in response to the "<CODE>new</CODE>" message. As it
turns out, <CODE>Object</CODE> will do the actual creation of the object
when sent a "<CODE>new</CODE>" message.
<P>
     One  more time in slow motion: the <CODE>Account</CODE> method
"<CODE>new</CODE>" wants to do some fiddling about when new objects are
created, but he also wants to let his parent do some work with a method of
the <EM>same name</EM>. By saying "<CODE>r := super new</CODE>" he is
letting his parent create the object, and then he is attaching it to the
variable "<CODE>r</CODE>". So after this line of code executes, we have a
brand new object of type <CODE>Account</CODE>, and "<CODE>r</CODE>" is
bound to it. You will understand this better as time goes on, but for now
scratch your head once, accept it as a recipe, and keep going.
<P>
     We have the new object, but we haven't set it  up  correctly.
Remember the hidden variable "<CODE>balance</CODE>" which we saw in the
beginning of this chapter? "<CODE>super new</CODE>" gives us the object
with the "<CODE>balance</CODE>" field containing nothing - we want our
<CODE>balance</CODE> field to start at 0<A HREF="smalltalk-tutorial.html#note10">[10]</A><A
name="ref10"></A></A>. So what we need to do is ask the object to set
itself up. By saying "<CODE>r init</CODE>", we are sending the
"<CODE>init</CODE>" message to our new <CODE>Account</CODE>. We'll define
this method in the next section - for now just assume that sending the
"<CODE>init</CODE>" message will get our <CODE>Account</CODE> set up.
<P>
     Finally, we say "<CODE>^r</CODE>".  In English, this is "return what
<CODE>r</CODE> is attached to". This means that whoever sent
"<CODE>Account</CODE>" the "<CODE>new</CODE>" message will get back this
brand new account. At the same time, our temporary variable
"<CODE>r</CODE>" ceases to exist.

<A NAME="4.4.Defininganinstancemethod"></A>
<H3>4.4.  Defining an instance method</H3>
<P>
     We need to define the "<CODE>init</CODE>"  method  for  our
<CODE>Account</CODE> objects, so that our "<CODE>new</CODE>" method defined
above will work.
<br>
Here's the Smalltalk code:
<PRE>
     !Account methodsFor: 'instance initialization'!
     init
          balance := 0
     !!
</PRE>
It looks quite a bit like the  previous  method  definition,
except  that  the  first  one  said  "<CODE>Account class
methodsFor:...</CODE>", and ours says "<CODE>Account
methodsFor:...</CODE>".  The  difference  is that the first one defined a
method for messages 
sent directly to "<CODE>Account</CODE>", but the second one is  for
messages  which  are sent to <CODE>Account</CODE> objects <EM>once they are
created</EM>. 
<P>
     The method named "<CODE>init</CODE>" has only one line,
"<CODE>balance  := 0</CODE>".   This  initializes the hidden variable
"<CODE>balance</CODE>" (actually called an <EM>instance variable</EM>  )
to  zero,  which  makes  
sense  for  an  account  balance.   Notice  that  the method
doesn't end  with  "<CODE>^r</CODE>"  or  anything  like  it - this  method
doesn't  return  a value to the message sender.  When you do
not specify a return value, Smalltalk  defaults  the  return
value  to  the  object  currently executing.  For clarity of
programming, you might consider explicitly returning  "<CODE>self</CODE>"
in cases where you intend the return value to be used<A
HREF="smalltalk-tutorial.html#note11">[11]</A><A name="ref11"></A></A>. 


<A NAME="4.5.LookingatourAccount"></A>
<H3>4.5.  Looking at our Account</H3>
<P>
     Let's create an <EM>instance</EM> of class <CODE>Account</CODE>:
<PRE>
     Smalltalk at: #a put: (Account new) !
</PRE>
Can  you  guess  what this does?  The "<CODE>Smalltalk at: #a put:
&lt;something&gt;</CODE>"  hearkens  back  to  chapter  2 - it  creates   a
Smalltalk  variable.   And  the  "<CODE>Account new</CODE>" creates a new
Account, and returns it.  So this line creates  a  Smalltalk
variable  named "<CODE>a</CODE>", and attaches it to a new
<CODE>Account</CODE> - all in 
one line.
<P>
     Let's take a look at the <CODE>Account</CODE> object  we  just
     created: 
<PRE>
     a printNl !
</PRE>
It prints:
<PRE>
     an Account
</PRE>
Hmmm... not very informative.  The problem is that we didn't
tell our <CODE>Account</CODE> how to print itself, so we're just  getting
the  default  system  "<CODE>printNl</CODE>"  method - which tells what the
object <EM>is</EM>, but not what it <EM>contains</EM>.  So clearly we must
add 
such a method:
<PRE>
     !Account methodsFor: 'printing'!
     printOn: stream
          super printOn: stream.
          ' with balance: ' printOn: stream.
          balance printOn: stream
     !!
</PRE>
Now give it a try again:
<PRE>
     a printNl !
</PRE>
which prints:
<PRE>
     an Account with balance: 0
</PRE>
This may seem a little strange. We added a new method,
<CODE>printOn:</CODE>, and our <CODE>printNl</CODE> message starts behaving
differently. It turns out that the <CODE>printOn:</CODE> message is the
central printing function - once you've defined it, all of the other
printing methods end up calling it. Its argument is a place to print to -
quite often it is the variable "<CODE>stdout</CODE>". This variable is
usually hooked to your terminal, and thus you get the printout to your
screen.
<P>
     The "<CODE>super printOn: stream</CODE>" lets our parent do what  it
did before - print out what our type is. The "<CODE>an Account</CODE>" part
of the printout came from this. "<CODE>' with balance: ' printOn:
stream</CODE>" creates the string "<CODE> with balance: </CODE>", and
prints it out to the stream, too. Finally, "<CODE>balance printOn:
stream</CODE>" asks whatever object is hooked to the "<CODE>balance</CODE>"
variable to print itself to the stream. We set "<CODE>balance</CODE>" to 0,
so the 0 gets printed out.

<A NAME="4.6.Movingmoneyaround"></A>
<H3>4.6.  Moving money around</H3>
<P>
     We  can  now  create accounts, and look at them.  As it
stands, though, our balance will always be 0 - what a tragedy!
Our  final  methods  will  let  us  deposit and spend money.
They're very simple:


<PRE>
     !Account methodsFor: 'moving money'!
     spend: amount
          balance := balance - amount
     !
     deposit: amount
          balance := balance + amount
     !!
</PRE>
With these methods you can now deposit and spend amounts  of
money.  Try these operations:
<PRE>
     a deposit: 125!
     a deposit: 20!
     a printNl!
     a spend: 10!
     a printNl!
</PRE>

<A NAME="4.7.Specializedobjects"></A>
<H3>4.7.  Specialized objects</H3>
<P>
     We  now have a generic concept, "<CODE>Account</CODE>".  We can create
them, check their balance, and move money in and out of them. They provide
a good foundation, but leave out important information that particular
types of accounts might want. In the next chapter, we'll take a look at
fixing this problem using <EM>subclasses</EM>.


<A NAME="5.TwoSubclassesfortheAccountClass"></A>
<H2>5.  Two Subclasses for the <CODE>Account</CODE> Class</H2>
<P>
     This chapter continues from  the  previous  chapter  in
demonstrating how one creates classes and subclasses in Smalltalk. In this
chapter we will create two special subclasses of <CODE>Account</CODE>,
known as <CODE>Checking</CODE> and <CODE>Savings</CODE>. We will continue
to <EM>inherit</EM> the capabilities of <CODE>Account</CODE>, but will
tailor the two kinds of objects to better manage particular kinds of
accounts.

<A NAME="5.1.TheSavingsclass"></A>
<H3>5.1.  The <CODE>Savings</CODE> class</H3>
<P>
     We create the <CODE>Savings</CODE> class as a subclass  of
<CODE>Account</CODE>. 
It  holds money, just like an <CODE>Account</CODE>, but has an additional
property that we will model: it is paid  interest  based  on
its  balance.   We create the class <CODE>Savings</CODE> as a subclass of
<CODE>Account</CODE>:
<PRE>
     Account subclass: #Savings
          instanceVariableNames: 'interest'
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !
</PRE>
The instance variable "<CODE>interest</CODE>"  will  accumulate  interest
paid.  Thus, in addition to the "<CODE>spend:</CODE>" and
"<CODE>deposit:</CODE>" messages which we inherit from our  parent,
<CODE>Account</CODE>,  we  will 
need  to  define a method to add in <EM>interest</EM> deposits, and a
way to clear  the  interest  variable  (which  we  would  do
yearly, after we have paid taxes).  We first define a method
for allocating a new account - we need to make sure  that  the
interest field starts at 0.
<PRE>
     !Savings methodsFor: 'initialization'!
     init
          interest := 0.
          ^ super init
     !!
</PRE>
Recall  that  the parent took care of the "<CODE>new</CODE>" message, and
created a new object of the appropriate  size.   After  creation,  the
parent  also  sent an "<CODE>init</CODE>" message to the new 
object.  As a subclass  of  <CODE>Account</CODE>,  the  new  object  will
receive  the  "<CODE>init</CODE>"  message  first;  it  sets  up  its own
instance variable, and then passes the "<CODE>init</CODE>" message up the
chain  to  let  its parent take care of its part of the initialization.
<P>
     With our new "<CODE>Savings</CODE>" account created, we  can  define
two methods for dealing specially with such an account:


<PRE>
     !Savings methodsFor: 'interest'!
     interest: amount
          interest := interest + amount.
          self deposit: amount
     !
     clearInterest
          | oldinterest |

          oldinterest := interest.
          interest := 0.
          ^oldinterest
     !!
</PRE>
The  first  method says that we add the "<CODE>amount</CODE>" to our
running total of <CODE>interest</CODE>.  The  line  "<CODE>self  deposit:
amount</CODE>" 
tells  Smalltalk  to  send ourselves a message, in this case
"<CODE>deposit: amount</CODE>".  This then causes Smalltalk  to  look  up
the  method  for  "<CODE>deposit:</CODE>",  which it finds in our parent,
Account.  Executing this method  then  updates  our  overall
balance<A HREF="smalltalk-tutorial.html#note12">[12]</A><A name="ref12"></A></A>.
<P>
     One  may wonder why we don't just replace this with the
simpler "<CODE>balance := balance + amount</CODE>".  The answer  lies  in
one of the philosophies of object-oriented languages in general, and
Smalltalk in particular.  Our goal is to encode  a 
technique  for  doing something <EM>once</EM> only, and then re-using
that technique when needed.   If  we  had  directly  encoded
"<CODE>balance  :=  balance  + amount</CODE>" here, there would have been
<EM>two</EM> places that knew  how  to  update  the  balance  from  a
deposit.  This may seem like a useless difference.  But consider if later
we decided to start counting  the  number  of 
deposits  made.   If  we  had  encoded "<CODE>balance := balance +
amount</CODE>" in each place that needed to update the balance,  we
would  have to hunt each of them down in order to update the
count  of  deposits.   By   sending   "<CODE>self</CODE>"   the   message
"<CODE>deposit:</CODE>",  we  need  only  update  this  method
<EM>once</EM>; each 
sender of this message would then automatically get the correct up-to-date
technique for updating the balance. 
<P>
     The  second  method,  "<CODE>clearInterest</CODE>",  is simpler.  We
create a temporary variable "<CODE>oldinterest</CODE>" to hold  the
current  amount  of interest.  We then zero out our interest to 
start the year afresh.  Finally, we return the old  interest
as  our  result, so that our year-end accountant can see how
much we made<A HREF="smalltalk-tutorial.html#note13">[13]</A><A name="ref13"></A></A>.

<A NAME="5.2.TheCheckingclass"></A>
<H3>5.2.  The <CODE>Checking</CODE> class</H3>
<P>
     Our  second  subclass  of <CODE>Account</CODE> represents a checking
account.  We will keep track of two facets:
<ul>
  <li> What check number we are on
  <li> How many checks we have left in our checkbook
</ul>
We will define this as another subclass of <CODE>Account</CODE>:
<PRE>
     Account subclass: #Checking
          instanceVariableNames: 'checknum checksleft'
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !
</PRE>
We have two instance variables, but we really only  need  to
initialize one of them - if there are no checks left, the current check
number can't matter.  Remember, our parent  class 
<CODE>Account</CODE>  will send us the "<CODE>init</CODE>" message.  We
don't need our 
own class-specific "<CODE>new</CODE>" function, since our  parent's  will
provide everything we need.
<PRE>
     !Checking methodsFor: 'Initialization'!
     init
          checksleft := 0.
          ^super init
     !!
</PRE>
As  in <CODE>Savings</CODE>, we inherit most of abilities from our
superclass, <CODE>Account</CODE>.  For  initialization,  we  leave
"<CODE>checknum</CODE>" 
alone,  but  set  the  number  of checks in our checkbook to
zero.  We finish by letting our parent class do its own initialization.

<A NAME="5.3.Writingchecks"></A>
<H3>5.3.  Writing checks</H3>
<P>
     We  will  finish  this  chapter  by adding a method for
spending money through our checkbook.  The mechanics of taking a message
and updating variables should be familiar: 
<PRE>
     !Checking methodsFor: 'spending'!
     newChecks: number count: checkcount
          checknum := number.
          checksleft := checkcount
     !

     writeCheck: amount
          | num |

          num := checknum.
          checknum := checknum + 1.
          checksleft := checksleft - 1.
          self spend: amount.
          ^ num
     !!
</PRE>
"<CODE>newChecks:</CODE>"  fills  our  checkbook  with checks.  We record
what check number we're starting with, and update the  count
of the number of checks in the checkbook.
<P>
     "<CODE>writeCheck:</CODE>"  merely notes the next check number, then
bumps up the check number, and down the check count. The message
"<CODE>self spend: amount</CODE>" resends the message "<CODE>spend:</CODE>"
to our own object. This causes its method to be looked up by Smalltalk. The
method is then found in our parent class, <CODE>Account</CODE>, and our
balance is then updated to reflect our spending.
<P>
     You can try the following examples:
<PRE>
     Smalltalk at: #c put: (Checking new) !
     c printNl !
     c deposit: 250 !
     c printNl !
     c newChecks: 100 count: 50 !
     c printNl !
     (c writeCheck: 32) printNl !
     c printNl !
</PRE>
For  amusement,  you might want to add a <CODE>printOn:</CODE> message to
the checking class so  you  can  see  the  checking-specific
information.
<P>
     In this chapter, you have seen how to create <EM>subclasses</EM>
of your own classes.  You have added new methods, and <EM>inherited</EM>
methods from the parent classes.  These techniques provide the majority of
the structure for building solutions to 
problems.   In  the following chapters we will be filling in
details on further language mechanisms and types,  and  providing   details
on  how  to  debug  software  written  in 
Smalltalk.


<A NAME="6.Codeblocks"></A>
<H2>6.  Code blocks</H2>
<P>
     The <CODE>Account</CODE>/<CODE>Saving</CODE>/<CODE>Checking</CODE>
example from the last chapter has several deficiencies. It has no record of
the checks and their values. Worse, it allows you to write a check when
there are no more checks - the Integer value for the number of checks will
just calmly go negative! To fix these problems we will need to introduce
more sophisticated control structures.

<A NAME="6.1.Conditionsanddecisionmaking"></A>
<H3>6.1.  Conditions and decision making</H3>
<P>
     Let's first add some code to keep you from writing  too
many  checks.   We will simply update our current method for
the <CODE>Checking</CODE> class; if you have entered the methods from the
previous  chapters, the old definition will be overridden by
this new one.
<PRE>
     !Checking methodsFor: 'spending'!
     writeCheck: amount
          | num |

          (checksleft &lt; 1)
               ifTrue: [ ^self error: 'Out of checks' ].
          num := checknum.
          checknum := checknum + 1.
          checksleft := checksleft - 1.
          self spend: amount
          ^ num
     !!
</PRE>
The two new lines are:
<PRE>
     (checksleft &lt; 1)
          ifTrue: [ ^self error: 'Out of checks' ].
</PRE>
At first glance, this appears to be a completely new structure. Look again!
The only new construct is the square brackets.
<P>
     The first line is a simple <EM>boolean</EM> expression.
"<CODE>checksleft</CODE>" is our integer, as initialized by our Checking
class. It is sent the message "<CODE>&lt;</CODE>", and the argument 1. The
current number bound to "<CODE>checksleft</CODE>" compares itself against
1, and returns a boolean object telling whether it is less than 1.
<P>
     Now this boolean - being either true or false - is sent the
message "<CODE>IfTrue:</CODE>", with an argument which is called  a
<EM>code 
block</EM>.  A code block is an object, just like any other.  But
instead of holding a number, or a Set, it  holds  executable
statements.
<P>
     So what does a boolean <EM>do</EM> with a code block which is an
argument to a <CODE>ifTrue:</CODE> message?  It depends on which boolean!
If  the  object  is  the "<CODE>true</CODE>" object, it executes the code
block it has been handed.  If it is the "<CODE>false</CODE>"  object,  it
returns  without  executing  the  code block.  So the traditional
"conditional  construct"  has   been   replaced   in 
Smalltalk  with  boolean objects which execute the indicated
code block or not, depending on their truth-value<A
HREF="smalltalk-tutorial.html#note14">[14]</A><A name="ref14"></A></A>. 
<P>
     In the case of our example, the actual code within  the
block  sends an error message to the current object.  <CODE>error:</CODE>
is handled by the parent class <CODE>Object</CODE>, and will  pop  up  an
appropriate  complaint when the user tries to write too many
checks.  In general, the way you handle  a  fatal  error  in
Smalltalk  is  to send an error message to yourself (through
the "<CODE>self</CODE>" pseudo-variable),  and  let  the  error  handling
mechanisms inherited from the <CODE>Object</CODE> class take over.
<P>
     As  you  might guess, there is also an <CODE>ifFalse:</CODE> message
which booleans  accept.   It  works  exactly  like  <CODE>ifTrue:</CODE>,
except  that  the logic has been reversed; a boolean "<CODE>false</CODE>"
will execute the codeblock, and a boolean "<CODE>true</CODE>" will not.
<P>
     You should take a little time to play with this  method
of  representing  conditionals.  You can run your checkbook,
but can also invoke the conditional functions directly:
<PRE>
     true ifTrue: [ 'Hello, world!' printNl ] !
     false ifTrue: [ 'Hello, world!' printNl ] !
     true ifFalse: [ 'Hello, world!' printNl ] !
     false ifFalse: [ 'Hello, world!' printNl ] !
</PRE>

<A NAME="6.2.Iterationandcollections"></A>
<H3>6.2.  Iteration and collections</H3>
<P>
     Now that we have some  sanity  checking  in  place,  it
remains  for  us  to  keep a log of the checks we write.  We
will do so by adding a <CODE>Dictionary</CODE>  object  to  our
<CODE>Checking</CODE> 
class,  logging  checks into it, and providing some messages
for querying our check-writing history.  But  this  enhancement  brings  up
a very interesting question - when we change  
the "shape" of an object (in this  case,  by  adding  a  new
<EM>instance  variable</EM>  to  the  <CODE>Checking</CODE> class - our
dictionary), 
what happens to the existing class, and its objects?
<P>
     The answer is that the old objects  continue  to  exist
with their current shape<A HREF="smalltalk-tutorial.html#note15">[15]</A><A name="ref15"></A></A>.
New objects will  have  the  new 
shape.   As  this  can lead to <EM>very</EM> puzzling behavior, it is
usually best to eradicate all of the old objects,  and  then
implement your changes.  If this were more than a toy object
accounting system, this would  probably  entail  saving  the
objects  off,  converting  to the new class, and reading the
objects back into the  new  format.   For  now,  we'll  just
ignore  what's currently there, and define our latest <CODE>Checking</CODE>
class. 
<PRE>
     Account subclass: #Checking
          instanceVariableNames: 'checknum checksleft history'
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !
</PRE>
<P>
     This is the same syntax as the last time we  defined  a
checking account, except that we have <EM>three</EM> instance variables -
the "<CODE>checknum</CODE>" and "<CODE>checksleft</CODE>" which have always
been there, and our new "<CODE>history</CODE>" variable. We must now feed
in our definitions for each of the messages our object can handle, since we
are basically defining a new class under an old name<A
HREF="smalltalk-tutorial.html#note16">[16]</A><A name="ref16"></A></A>. Go ahead and do this now -
the methods are in chapter 5. We are using the same <CODE>Account</CODE>
class, so you only need to do the <CODE>Checking</CODE> methods.
<P>
     With our new <CODE>Checking</CODE> instance variable, we are all set
to  start  recording our checking history.  Our first change
will be in the "<CODE>init</CODE>" message handling:
<PRE>
     !Checking methodsFor: 'initialization'!
     init
          checksleft := 0.
          history := Dictionary new.
          ^ super init
     !!
</PRE>
This provides us with a <CODE>Dictionary</CODE>, and hooks it to our  new
"<CODE>history</CODE>" variable.
<P>
     Our  next  method  records  each check as it's written.
The method is a little more involved, as  we've  added  some
more sanity checks to the writing of checks.
<PRE>
     !Checking methodsFor: 'spending'!
     writeCheck: amount
          | num |

          "Sanity check that we have checks left in our checkbook"
          (checksleft &lt; 1)
               ifTrue: [ ^self error: 'Out of checks' ].

          "Make sure we've never used this check number before"
          num := checknum.
          (history includesKey: num)
               ifTrue: [ ^self error: 'Duplicate check number' ].

          "Record the check number and amount"
          history at: num put: amount.

          "Update our next checknumber, checks left, and balance"
          checknum := checknum + 1.
          checksleft := checksleft - 1.
          self spend: amount.
          ^ num
     !!
</PRE>
<P>
     We  have  added  three  things to our latest version of
<CODE>writeCheck:</CODE>.  First, since our routine has  become  somewhat
involved,  we  have  added  comments.   In Smalltalk, single
quotes are used for strings; double quotes enclose comments.
We have added comments before each section of code.
<P>
     Second,  we have added a sanity check on the check number we propose
to use. <CODE>Dictionary</CODE> objects respond to the
<CODE>includesKey:</CODE> message with a boolean, depending on whether
something is currently stored under the given key in the dictionary. If the
check number is already used, the <CODE>error:</CODE> message is sent to
our object, aborting the operation.
<P>
     Finally, we add a new entry to the dictionary.  We have
already  seen  the  <CODE>at:put:</CODE> message from chapter 2.  Our use
here simply associates a check  number  with  an  amount  of
money  spent<A HREF="smalltalk-tutorial.html#note17">[17]</A><A name="ref17"></A></A>.  With
this,  we now have a working <CODE>Checking</CODE> 
class, with reasonable sanity checks and per-check  information.
<P>
     Let  us  finish the chapter by enhancing our ability to
get access to all this information.  We will start with some
simple print-out functions.
<PRE>
     !Checking methodsFor: 'printing'!
     printOn: stream
          super printOn: stream.
          ', checks left: ' printOn: stream.
          checksleft printOn: stream.
          ', checks written: ' printOn: stream.
          (history size) printOn: stream.
     !
     check: num
          | c |
          c := history at: num ifAbsent: [ ^self error: 'No such check #' ].
          ^c
     !!
</PRE>
There should be very few surprises here. We format and print our
information, while letting our parent classes handle their own share of the
work. When looking up a check number, we once again take advantage of the
fact that blocks of executable statements are an object; in this case, we
are using the <CODE>at:ifAbsent:</CODE> message supported by the
<CODE>Dictionary</CODE> class. If the requested key value is not found in
the dictionary, the code block is executed. This allows us to customize our
error handling, as the generic error would only tell the user "<CODE>key
not found</CODE>".
<P>
     While we can look up a check if we know its number,  we
have  not  yet written a way to "riffle through" our collection of checks.
The following function loops over the checks, printing them out one per
line. Because there is currently only a single numeric value under each
key, this might seem wasteful. But we have already considered storing
multiple values under each check number, so it is best to leave some room
for each item. And, of course, because we are simply sending a printing
message to an object, we will not have to come back and re-write this code
so long as the object in the dictionary honors our
<CODE>printNl</CODE>/<CODE>printOn:</CODE>  messages. 
<PRE>
     !Checking methodsFor: 'printing'!
     printChecks
          history associationsDo: [:assoc|
               (assoc key) print.
               ' - ' print.
               (assoc value) printNl.
          ]
     !!
</PRE>
We  still  see  a code block object being passed to the dictionary, but
"<CODE>:assoc|</CODE>" is something new.  A code  block  can 
optionally receive <EM>arguments</EM>.  In this case, the argument is
the key/value pair, known in Smalltalk  as  an  <EM>Association</EM>.
This  is  the  way  that  a  dictionary  object  stores  its
key/value pairs internally.   In  fact,  when  you  sent  an
<CODE>at:put:</CODE>  message  to a dictionary object, the first thing it
does is pack them into a new  object  from  the  <CODE>Association</CODE>
class.  If you only wanted the value portion, you could call
<CODE>history</CODE> with a <CODE>do:</CODE> message instead.
<P>
     Our code merely uses the "<CODE>key</CODE>" and "<CODE>value</CODE>"
messages to ask the association for the two values. We then invoke our
printing interface upon them. While the <CODE>printNl</CODE> message
implicitly uses "<CODE>stdout</CODE>", we don't want a newline until the
end, so the "<CODE>print</CODE>" message is used instead. It is pretty much
the same as "<CODE>printNl</CODE>", except it doesn't add a newline.
<P>
     It is important that you be clear on  the  relationship
between an <CODE>Association</CODE> and the argument to a code block. In
this example, we passed a <CODE>associationsDo:</CODE> message to a
dictionary. A dictionary invokes the passed code block with an
<CODE>Association</CODE> when processing an <CODE>associationsDo:</CODE>
message. But code blocks can receive <EM>any</EM> type of argument - the
type is determined by the code which invokes the code block;
<CODE>Dictionary</CODE>, in this case. In the next chapter we'll see more
on how code blocks are used; we'll also look at how you can invoke code
blocks in your own code.

<A NAME="7.Codeblocks,parttwo"></A>
<H2>7.  Code blocks, part two</H2>
<P>
     In the last chapter, we looked at how code blocks could
be used to build conditional expressions, and how you could iterate across
all entries in a collection<A HREF="smalltalk-tutorial.html#note18">[18]</A><A
name="ref18"></A></A>. We built our own code blocks, and handed them off
for use by system objects. But there is nothing magic about invoking code
blocks; your own code will often need to do so. This chapter will shows
some examples of loop construction in Smalltalk, and then demonstrate how
you invoke code blocks for yourself.

<A NAME="7.1.Integerloops"></A>
<H3>7.1.  Integer loops</H3>
<P>
     Integer loops are constructed by telling  a  number  to
drive the loop.  Try this example to count from 1 to 20:
<PRE>
     1 to: 20 do: [:x| x printNl ] !
</PRE>
There's also a way to count up by more than one:
<PRE>
     1 to: 20 by: 2 do: [:x| x printNl ] !
</PRE>
Finally, counting down is done with a negative interval:
<PRE>
     20 to: 1 by: -1 do: [:x| x printNl ] !
</PRE>

<A NAME="7.2.Intervals"></A>
<H3>7.2.  Intervals</H3>
<P>
     It  is also possible to represent a range of numbers as
a standalone object.  This allows you to represent  a  range
of  numbers  as  a single object, which can be passed around
the system.
<PRE>
     Smalltalk at: #i put: (Interval from: 5 to: 10) !
     i printNl !
     i do: [:x| x printNl] !
</PRE>
As with the integer  loops,  the  <CODE>Interval</CODE>  class  can  also
represent steps greater than 1.  It is done much like it was
for our numeric loop above:
<PRE>
     i := (Interval from: 5 to: 10 by: 2)
     i printNl !
     i do: [:x| x printNl] !
</PRE>

<A NAME="7.3.Invokingcodeblocks"></A>
<H3>7.3.  Invoking code blocks</H3>
<P>
     Let us revisit the checking example and  add  a  method
for scanning only checks over a certain amount. This would allow our user
to find "big" checks, by passing in a value below which we will not invoke
their function. We will invoke their code block with the check number as an
argument; they can use our existing check: message to get the amount.
<PRE>
     !Checking methodsFor: 'scanning'!
     checksOver: amount do: aBlock
          history associationsDo: [:assoc|
               ((assoc value) &gt; amount)
                    ifTrue: [aBlock value: (assoc key)]
          ]
     !!
</PRE>
The structure of this loop is much like our <CODE>printChecks</CODE>
message from chapter 6.  However, in this case we consider each 
entry, and only invoke the supplied  block  if  the  check's
value is greater than the specified amount.  The line:
<PRE>
     ifTrue: [aBlock value: (assoc key)]
</PRE>
invokes  the user-supplied block, passing as an argument the
association's key, which is the check  number.   The  <CODE>value:</CODE>
message,  when  received  by  a  code block, causes the code
block to  execute.   Code  blocks  take  "<CODE>value</CODE>",
"<CODE>value:</CODE>", 
"<CODE>value:value:</CODE>",  and  "<CODE>value:value:value:</CODE>"
messages, so you 
can pass from 0 to 3 arguments to a code block<A HREF="smalltalk-tutorial.html#note19">[19]</A><A
name="ref19"></A></A>. You  might 
find  it  puzzling  that an association takes a "<CODE>value</CODE>"
message, and so does a code block.  Remember, each  object  can 
do its own thing with a message.  A code block gets <EM>run</EM> when
it  receives  a  "<CODE>value</CODE>"  message.   An  association  merely
returns the value part of its key/value pair.  The fact that
both take the same message is, in this case, coincidence.
<P>
     Let's quickly set up a new checking account  with  $250
(wouldn't  this  be  nice  in real life?) and write a couple
checks.  Then we'll see if our new method does the job  correctly:
<PRE>
     Smalltalk at: #mycheck put: (Checking new) !
     mycheck deposit: 250 !
     mycheck newChecks: 100 count: 40 !
     mycheck writeCheck: 10 !
     mycheck writeCheck: 52 !
     mycheck writeCheck: 15 !
     mycheck checksOver: 1 do: [:x| printNl] !
     mycheck checksOver: 17 do: [:x| printNl] !
     mycheck checksOver: 200 do: [:x| printNl] !
</PRE>
<P>
     We  will finish this chapter with an alternative way of
writing our <CODE>checksOver:</CODE> code.  In this example, we will  use
the  message  <CODE>select:</CODE>  to  pick  the checks which exceed our
value, instead of doing the comparison  ourselves.   We  can
then  invoke the new resulting collection against the user's
code   block.    Unlike   our   previous    definition    of
<CODE>checksOver:do:</CODE>,  this  one  passes the user's code block the
association, not just a check number.  How could  this  code
be rewritten to remedy this, while still using <CODE>select:</CODE>?
<PRE>
     !Checking methodsFor: 'scanning'!
     checksOver: amount do: aBlock
          | chosen |
          chosen := history select: [:amt| amt &gt; amount].
          chosen associationsDo: aBlock
     !!
</PRE>
<P>
     You  can  use  the same set of tests that we ran above.
Notice that our code block:
<PRE>
     [:x| x printNl]
</PRE>
now prints out an <CODE>Association</CODE>. This has the very nice effect -
with our old method, we were told which check numbers were above a given
amount. With this new method, we get the check number and amount in the
form of an <CODE>Association</CODE>. When we print an association, since
the key is the check number and the value is the check amount, we get a
list of checks over the amount in the format:
<PRE>
     CheckNum -&gt; CheckVal
</PRE>


<A NAME="8.WhenThingsGoBad"></A>
<H2>8.  When Things Go Bad</H2>
<P>
     So far we've been working with examples which work  the
first time.  If you didn't type them in correctly, you probably received a
flood  of  unintelligible  complaints.   You 
probably  ignored  the  complaints,  and  typed  the example
again.
<P>
     When developing your own Smalltalk code, however, these
messages  are the way you find out what went wrong.  Because
your objects, their methods, the error  printout,  and  your
interactive  environment  are  all contained within the same
Smalltalk session, you can use these error messages to debug
your code using very powerful techniques.

<A NAME="8.1.ASimpleError"></A>
<H3>8.1.  A Simple Error</H3>
<P>
     First, let's take a look at a typical error.  Type:
<PRE>
     7 plus: 1 !
</PRE>
This will print out:
<PRE>
     7 did not understand selector 'plus:'

     UndefinedObject&gt;&gt;#executeStatements
     UndefinedObject&gt;&gt;nil
</PRE>
The first line is pretty simple; we sent a message to the "<CODE>7</CODE>"
object which was not understood; not surprising since the
"<CODE>plus</CODE>" operation should have been "<CODE>+</CODE>". The two
remaining lines reflect the way the GNU Smalltalk invokes code which we
type to our command prompt; it generates a block of code which is invoked
via an internal function "<CODE>executeStatements</CODE>". Thus, this
output tells you that you directly typed a line which sent an invalid
message to the "<CODE>7</CODE>" object.
<P>
     The  last  two lines of the error output are actually a
stack backtrace.  The most recent call is the one nearer the
top  of  the  screen.  In the next example, we will cause an
error which happens deeper within an object.

<A NAME="8.2.NestedCalls"></A>
<H3>8.2.  Nested Calls</H3>
<P>
     Type the following lines:
<PRE>
     Smalltalk at: #x put: (Dictionary new) !
     x at: 1 !
</PRE>
The error you receive will look like:
<PRE>
     Dictionary new: 32 "&lt;0x33788&gt;" error: key not found

     MethodContext&gt;&gt;#value
     Dictionary&gt;&gt;#at:ifAbsent:
     Dictionary&gt;&gt;#at
     UndefinedObject&gt;&gt;#executeStatements
     UndefinedObject&gt;&gt;nil
</PRE>
<P>
     The error itself is pretty clear; we  asked  for  something  within
the Dictionary which wasn't there. The object which had the error is
identified as "<CODE>Dictionary new: 32</CODE>". A
<CODE>Dictionary</CODE>'s default size is 32; thus, this is the object we
created with "<CODE>Dictionary new</CODE>".
<P>
     The stack backtrace shows us the inner structure of how
a  <CODE>Dictionary</CODE> responds to the <CODE>at:</CODE> message.  Our
hand-entered 
command causes the usual two entries for  "<CODE>UndefinedObject</CODE>".
Then  we see a <CODE>Dictionary</CODE> object responding to an
"<CODE>at:</CODE>" message (the "<CODE>Dictionary&gt;&gt;#at</CODE>" line).
This  code  called  the 
object  with  an "<CODE>at:ifAbsent:</CODE>" message.  All of a sudden, a
different object receives a "<CODE>value</CODE>" message,  and  then  the
error happened.
<P>
     This  isn't  quite true; the error happened in the
     <CODE>Dictionary</CODE> object.  The mystery is where  this
     "<CODE>MethodContext</CODE>" 
came  from.   Fortunately,  it isn't much of a mystery.  The
answer lies in what we covered in  the  last  two  chapters:
code blocks.
<P>
     A  very  common way to handle errors in Smalltalk is to
hand down a block of code which will be called when an error occurs. For
the <CODE>Dictionary</CODE> code, the "<CODE>at:</CODE>" message passes in
a block of code to the <CODE>at:ifAbsent:</CODE> code to be called when
"<CODE>at:ifAbsent:</CODE>" can't find the given key. Thus, without even
looking at the code for <CODE>Dictionary</CODE> itself, we can guess that
the <CODE>Dictionary</CODE> "<CODE>at:</CODE>" message handling looks
something like:
<PRE>
     at: key ifAbsent: errCodeBlock
          ...look for key...
          (keyNotFound) ifTrue: [ ^(errCodeBlock value) ]
          ...

     at: key
          ^self at: key ifAbsent: [^self error: 'key not found']
</PRE>
The key is that we see in the stack backtrace that
<CODE>at:ifAbsent:</CODE> is called from <CODE>at:</CODE>, and a
<CODE>MethodContext</CODE> is called to give the error. Once we realize
that a <CODE>MethodContext</CODE> is just a fancy name for a code block, we
can guess that <CODE>at:</CODE> handed in a code block to print an error,
and <CODE>at:ifAbsent:</CODE> used the standard "<CODE>value</CODE>"
message to invoke this code block when it realized that the requested key
couldn't be found in the <CODE>Dictionary</CODE>.
<P>
     It  would  be nice if each entry on the stack backtrace
included source line numbers.  Unfortunately, at this  point
GNU  Smalltalk doesn't provide this feature.  Of course, you
have the source code available....

<A NAME="8.3.SomeShortcomingsinGNUSmalltalk"></A>
<H3>8.3.  Some Shortcomings in GNU Smalltalk</H3>
<P>
     Unfortunately,  there  are  some   errors   which   GNU
Smalltalk is not very helpful in detecting. This information applies to the
latest version currently available - GNU Smalltalk 1.1.1. Try indexing
something which isn't any sort of <CODE>Collection</CODE>:
<PRE>
     (7 at: 99) printNl !
</PRE>
One  would  expect  to  receive  an error<A HREF="smalltalk-tutorial.html#note20">[20],</A><A
name="ref20"></A></A> but instead GNU 
Smalltalk simply returns the receiving object - 7.  Similarly,
one would expect <CODE>Array</CODE> bounds to be checked:
<PRE>
     Smalltalk at: #x put: (Array new: 10) !
     (x at: 7 put: 123) printNl !
     (x at: 11 put: 1234) printNl !
     (x at: 7) printNl !
     (x at: 11) printNl !
</PRE>
But this example returns no error in GNU  Smalltalk<A
HREF="smalltalk-tutorial.html#note21">[21]</A><A name="ref21"></A></A>.  When 
an  assignment  to  an  array  slot is correct, the returned
value is the value assigned - 123  in  this  case.   When  you
assign  outside the array bounds, you will receive the array
object itself as the  result!   Thus,  if  you  accidentally
index  your  array  incorrectly, you will have to figure out
what happened from a place further in  your  code  where  an
error  crops up because your code was trying to operate upon
an <EM>element</EM> of the array, but instead is working on the array
itself.

<A NAME="8.4.LookingatObjects"></A>
<H3>8.4.  Looking at Objects</H3>
<P>
     When  you  are chasing an error, it is often helpful to
examine the  instance  variables  of  your  objects.   While
strategic  "<CODE>printNl</CODE>"s will no doubt help, you can look at an
object without having to write all the code  yourself.   The
"<CODE>inspect</CODE>"  message  works  on  any object, and dumps out the
values of each instance variable within the object.  Thus:
<PRE>
     Smalltalk at: #x put: (Interval from: 1 to: 5) !
     x inspect !
</PRE>
displays:
<PRE>
     An instance of Interval
       start: 1
       stop: 5
       step: 1
</PRE>
<P>
     There's one thing the object inspector doesn't display - 
the  contents  of an <EM>indexed class</EM>.  Since we haven't looked
at this kind of object yet, we'll  leave  this  to  its  own
chapter.
<P>
     We'll  finish  this  chapter by emphasizing a technique
which has already been covered - the use of the "<CODE>error:</CODE>"
message in your own objects. As you saw in the case of
<CODE>Dictionary</CODE>, an object can send itself an <CODE>error:</CODE>
message with a descriptive string to abort execution and dump a stack
backtrace. You should plan on using this technique in your own objects. It
can be used both for explicit user-caused errors, as well as in internal
sanity checks.

<A NAME="9.CoexistingintheClassHierarchy"></A>
<H2>9.  Coexisting in the Class Hierarchy</H2>
<P>
     The early chapters of this paper discussed  classes  in
one of two ways.  The "toy" classes we developed were rooted
at <CODE>Object</CODE>;  the  system-provided  classes  were  treated  as
immutable entities.  While one shouldn't modify the behavior
of the standard classes  lightly,  "plugging  in"  your  own
classes  in  the  right  place  among  their system-provided
brethren can provide you powerful new classes with very little effort.
<P>
     This  chapter  will  create  two complete classes which
enhance the existing Smalltalk  hierarchy.   The  discussion
will  start  with  the  issue  of  where  to connect our new
classes, and then continue onto implementation.   Like  most
programming  efforts,  the result will leave many possibilities for
improvements.  The framework, however, should begin 
to  give  you  an  intuition  of  how  to  develop  your own
Smalltalk classes.

<A NAME="9.1.TheExistingClassHierarchy"></A>
<H3>9.1.  The Existing Class Hierarchy</H3>
<P>
     To discuss where a new class might go, it is helpful to
have  a  map  of  the current classes.  The following is the
class hierarchy of GNU Smalltalk 1.1.1.   Indentation  means
that  the  line inherits from the earlier line with one less
level of indentation<A HREF="smalltalk-tutorial.html#note22">[22]</A><A name="ref22"></A></A>.

<PRE>
     Object
         Autoload
         Behavior
             ClassDescription
                 Class
                 Metaclass
         BlockContext
         Boolean
             False
             True
         CFunctionDescriptor
         CObject
         Collection
             Bag
             MappedCollection
             SequenceableCollection
                 ArrayedCollection
                     Array
                     ByteArray
                     CompiledMethod
                     String
                         Symbol
                 Interval
                 LinkedList
                     Semaphore
                 OrderedCollection
                     SortedCollection
             Set
                 Dictionary
                     IdentityDictionary
                     SystemDictionary
         Delay
         FileSegment
         Link
             Process
             SymLink
         Magnitude
             Character
             Date
             LookupKey
                 Association
             Number
                 Float
                 Integer
             Time
         Memory
             ByteMemory
             WordMemory
         Message
         MethodContext
         MethodInfo
         ProcessorScheduler
         SharedQueue
         Stream


             PositionableStream
                 ReadStream
                 WriteStream
                     ReadWriteStream
                         FileStream
             Random
             TokenStream
         UndefinedObject
</PRE>
<P>
     While  initially  a  daunting list, you should take the
time to hunt down the classes we've examined in this paper so far. Notice,
for instance, how an <CODE>Array</CODE> is a subclass below the
"<CODE>SequenceableCollection</CODE>" class. This makes sense; you can walk
an <CODE>Array</CODE> from one end to the other. By contrast, notice how a
<CODE>Set</CODE> is at the same level as
<CODE>SequenceableCollection</CODE>. It doesn't make sense to walk a
<CODE>Set</CODE> from one end to the other.
<P>
     A little puzzling is the relationship of  a  <CODE>Dictionary</CODE>
to a Set; why is a <CODE>Dictionary</CODE> a subclass of a
<CODE>Set</CODE>? The answer lies in the basic structure of both a
<CODE>Set</CODE> and a <CODE>Dictionary</CODE>. Both hold an unordered
collection of objects. For a set, they're <EM>any</EM> objects; for a
<CODE>Dictionary</CODE>, they are <CODE>Associations</CODE>. Thus,
<CODE>Dictionary</CODE> inherits some of the more basic mechanisms for
creating itself, and then adds an extra layer of interpretation.
<P>
     Finally, look at the treatment of numbers - starting with
the class <CODE>Magnitude</CODE>. While numbers can be ordered by "less
than", "greater than", and so forth, so can a number of <EM>other</EM>
objects. Each subclass of <CODE>Magnitude</CODE> is such an object. So we
can compare characters with other characters, dates with other dates, and
times with other times, as well as numbers with numbers<A
HREF="smalltalk-tutorial.html#note23">[23]</A><A name="ref23"></A></A>.

<A NAME="9.2.ThoseDarnArrays"></A>
<H3>9.2.  Those Darn Arrays</H3>
<P>
     Imagine that you're chasing an array problem,  and  the
lack  of  a  clear  bounds check is making it too hard.  You
could modify the Smalltalk implementation, but perhaps  it's
in  somebody  else's directory, so it wouldn't be practical.
Why not add a subclass, put some sanity checks in the  array
indexing, and use our superclass to do all the work?

<PRE>
     Array variableSubclass: #CheckedArray
          instanceVariableNames: ''
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !

     !CheckedArray methodsFor: 'bounds checking'!
     boundsCheck: index
          ((index &lt; 1) | (index &gt; (self basicSize))) ifTrue: [
               ^self illegalIndex
          ]
     !
     illegalIndex
          ^self error: 'Illegal index'
     !!

     !CheckedArray methodsFor: 'basic'!
     at: index
          self boundsCheck: index.
          ^super at: index

     !
     at: index put: val
          self boundsCheck: index.
          ^super at: index put: val
     !!
</PRE>
<P>
     Much  of  the  machinery  of  adding  a class should be
familiar.  Instead of our usual <CODE>subclass:</CODE> message, we use  a
<CODE>variableSubclass:</CODE>  message.   This  reflects  the underlying
structure of an <CODE>Array</CODE> object; we'll  delay  discussing  this
until the chapter on the nuts and bolts of arrays. In any case, we
<EM>inherit</EM> all of the actual knowledge of how to create arrays,
reference them, and so forth. All that we do is intercept <CODE>at:</CODE>
and <CODE>at:put:</CODE> messages, and call our common function to validate
the array index. The way that we coded the bounds check bears a little
examination.
<P>
     Making a first cut at  coding  the  bounds  check,  you
might  have coded the bounds check in <CODE>CheckedArray</CODE>'s methods
twice - once for <CODE>at:</CODE>, and again for <CODE>at:put:</CODE>.  As
always, it's preferable to code things <EM>once</EM>, and then re-use them.
So we instead add a method for bounds checking "<CODE>boundsCheck:</CODE>",
and use it for both cases. If we ever wanted to enhance the bounds checking
(perhaps enhance the error message to print the offending index value?), we
only have to change it in one place.
<P>
     The actual math for calculating whether the bounds have
been  violated  is  a little interesting.  The first part of
the expression:
<PRE>
     ((index &lt; 1) | (index &gt; (self basicSize)))
</PRE>
is true if the index is less than 1, otherwise  it's  false.
This  part of the expression thus becomes the boolean object
true or false.  The boolean object then receives the message
"<CODE>|</CODE>",  and  the  argument  "<CODE>(index &gt; (self
basicSize))</CODE>".  "<CODE>|</CODE>" 
means "or" - we want to OR together the two  possible  illegal
range checks.  What is the second part of the expression?<A
HREF="smalltalk-tutorial.html#note24">[24]</A><A name="ref24"></A></A> 
<P>
     "<CODE>index</CODE>"  is  our  argument, an integer; it receives the
message "<CODE>&gt;</CODE>", and thus will compare itself to the value
"<CODE>self basicSize</CODE>" returns. While we haven't covered the
underlying structures Smalltalk uses to build arrays, we can briefly say
that the "<CODE>basicSize</CODE>" message returns the number of elements
the Array object can contain. So the index is checked to see if it's less
than 1 (the lowest legal <CODE>Array</CODE> index) or greater than the
highest allocated slot in the <CODE>Array</CODE>. If it is either (the
"<CODE>|</CODE>" operator), the expression is true, otherwise false.
<P>
     From there it's downhill; our boolean object receives the
<CODE>ifTrue:</CODE> message, and a code block which will send an error
message to the object. Why do we have a separate message just to print the
error? For purposes of this example, it's not needed. But one could
conceive, in general, of a couple of different sanity checks all sharing
the same mechanism for actually printing the error message. So we'll write
it this way anyway.

<A NAME="9.3.AddingaNewKindofNumber"></A>
<H3>9.3.  Adding a New Kind of Number</H3>
<P>
     If we were programming an application which did a large
amount of complex math, we could probably manage it  with  a
number  of  two-element arrays.  But we'd forever be writing
in-line code for the math and comparisons; it would be  much
easier to just implement an object class to support the complex numeric
type.  Where in the class hierarchy would it be 
placed?
<P>
     You've probably already guessed - but let's step down the
hierarchy anyway. <EM>Everything</EM> inherits from Object, so that's a
safe starting point. Complex numbers can not be compared with
"<CODE>&lt;</CODE>" and "<CODE>&gt;</CODE>", and yet we strongly suspect
that, since they are numbers, we should place them under the
<CODE>Number</CODE> class. But <CODE>Number</CODE> inherits from
<CODE>Magnitude</CODE> - how do we resolve this conflict? A subclass can
place itself under a superclass which allows some operations the subclass
doesn't wish to allow. All that you must do is make sure you intercept
these messages and return an error. So we will place our new
<CODE>Complex</CODE> class under <CODE>Number</CODE>, and make sure to
disallow comparisons.
<P>
     One can reasonably ask whether the real  and  imaginary
parts  of  our  complex  number  will be integer or floating
point.  In the grand Smalltalk tradition, we'll  just  leave
them  as objects, and hope that they respond to numeric messages
reasonably.  If they don't, the  user  will  doubtless 
receive  errors and be able to track back their mistake with
little fuss.
<P>
     We'll define the four basic math operators, as well  as
the  (illegal)  relationals.  We'll add <CODE>printOn:</CODE> so that the
printing methods work, and that should give us  our  <CODE>Complex</CODE>
class.   The  class  as  presented suffers some limitations,
which we'll cover later in the chapter.



<PRE>
     Number subclass: #Complex
          instanceVariableNames: 'realpart imagpart'
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !
     !Complex class methodsFor: 'creating'!
     new
          ^self error: 'use real:imaginary:'
     !
     new: ignore
          ^self new
     !
     real: r imaginary: i
          ^(super new) setReal: r setImag: i
     !!

     !Complex methodsFor: 'creating--private'!
     setReal: r setImag: i
          realpart := r.
          imagpart := i.
          ^self
     !!

     !Complex methodsFor: 'basic'!
     real
          ^realpart
     !
     imaginary
          ^imagpart
     !!

     !Complex methodsFor: 'math'!
     + val
          ^Complex real: (realpart + (val real))
               imaginary: (imagpart + (val imaginary))
     !
     - val
          ^Complex real: (realpart - (val real))
               imaginary: (imagpart - (val imaginary))
     !
     * val
          ^Complex real: ((realpart * (val real)) - (imagpart * (val imaginary)))
               imaginary: ((realpart * (val imaginary)) +
                    (imagpart * (val real)))
     !
     / val
          | d r i |
          d := ((val real) * (val real)) + ((val imaginary) * (val imaginary)).
          r := ((realpart * (val real)) + (imagpart * (val imaginary))) / d.
          i := ((imagpart * (val real)) - (realpart * (val imaginary))) / d.
          ^Complex real: r imaginary: i
     !!

     !Complex methodsFor: 'comparison'!


     = val
          ^((realpart = (val real)) &amp; (imagpart = (val imaginary)))
     !
     &gt; val
          ^self shouldNotImplement
     !
     &gt;= val
          ^self shouldNotImplement
     !
     &lt; val
          ^self shouldNotImplement
     !
     &lt;= val
          ^self shouldNotImplement
     !!

     !Complex methodsFor: 'printing'!
     printOn: aStream
          aStream nextPut: $(.
          realpart printOn: aStream.
          aStream nextPut: $,.
          imagpart printOn: aStream.
          aStream nextPut: $)
     !!
</PRE>
<P>
     There should be surprisingly little which  is  actually
new in this example. The printing method uses both <CODE>printOn:</CODE> as
well as <CODE>nextPut:</CODE> to do its printing. While we haven't covered
it, it's pretty clear that "<CODE>$(</CODE>" generates the ASCII character
"<CODE>(</CODE>" as an object, and <CODE>nextPut:</CODE> puts its argument
as the next thing on the stream.
<P>
     The  math  operations all generate a new object, calculating the real
and imaginary parts, and invoking the <CODE>Complex</CODE> class to create
the new object. Our creation code is a little more compact than earlier
examples; instead of using a local variable to name the newly-created
object, we just use the return value and send a message directly to the new
object. Our initialization code explicitly returns self; what would happen
if we left this off?<A HREF="smalltalk-tutorial.html#note25">[25]</A><A name="ref25"></A></A>

<A NAME="9.4.InheritanceandPolymorphism"></A>
<H3>9.4.  Inheritance and Polymorphism</H3>
<P>
     This is a good time to look at what we've done with the
two previous examples at a higher level. With the <CODE>CheckedArray</CODE>
class, we <EM>inherited</EM> almost all of the functionality of arrays,
with only a little bit of code added to address our specific needs. While
you may have not thought to try it, all the existing methods for an Array
continue to work without further effort - you might find it interesting to
ponder why the following still works:
<PRE>
     Smalltalk at: #a put: (CheckedArray new: 10) !
     a at: 5 put: 1234 !
     a do: [:i| i printNl ] !
</PRE>
The  strength of inheritance is that you focus on the incremental changes
you make; the things you  <EM>don't</EM>  change  will 
generally continue to work.
<P>
     In  the  <CODE>Complex</CODE>  class,  the value of
<EM>polymorphism</EM> was exercised. A <CODE>Complex</CODE> number responds
to exactly the same set of messages as any other number. If you had handed
this code to someone, they would know how to do math with
<CODE>Complex</CODE> numbers without further instruction. Compare this with
C, where a complex number package would require the user to first find out
if the <CODE>complex-add</CODE> function was <CODE>complex_plus()</CODE>,
or perhaps <CODE>complex_add()</CODE>, or <CODE>add_complex()</CODE>,
or....

<A NAME="9.5.LimitationsoftheComplexClass"></A>
<H3>9.5.  Limitations of the <CODE>Complex</CODE> Class</H3>
<P>
     One glaring deficiency is present in the <CODE>Complex</CODE> class - 
what happens if you mix normal numbers with <CODE>Complex</CODE> numbers?
Currently,  the  <CODE>Complex</CODE>  class  assumes  that  it will only
interact with other <CODE>Complex</CODE> numbers.  But this is
unrealistic - mathematically,  a "normal" number is simply one with an 
imaginary part of 0.  Smalltalk was designed to  allow  numbers  to
<EM>coerce</EM> themselves into a form which will work with 
other numbers.
<P>
     The system is clever and requires very little additional code.
Unfortunately, it would have tripled the amount of explanation required. If
you're interested in how coercion works in GNU Smalltalk, you should find
the Smalltalk library source, and trace back the execution of the
<CODE>retry:coercing:</CODE> messages. You want to consider the value which
the 
"<CODE>generality</CODE>" message returns for each type of number. Finally,
you need to 
examine the <CODE>coerce:</CODE> handling in each numeric class.


<A NAME="10.SmalltalkStreams"></A>
<H2>10.  Smalltalk Streams</H2>
<P>
     Our examples have used a  mechanism  extensively,  even
though  we  haven't discussed it yet.  The <CODE>Stream</CODE> class
provides a framework for a number of data structures, including 
input  and output functionality, queues, and endless sources
of dynamically-generated data.  A Smalltalk stream is  quite
similar  to  the  UNIX streams you've used from C.  A stream
provides a sequential view to an underlying resource; as you
read  or  write elements, the stream position advances until
you finally reach the end of the  underlying  medium.   Most
streams  also allow you to <EM>set</EM> the current position, providing
random access to the medium. 

<A NAME="10.1.TheOutputStream"></A>
<H3>10.1.  The Output Stream</H3>
<P>
     The examples in this book all work because  they  write
their output to the "<CODE><CODE>stdout</CODE></CODE>" stream. Each class
implements the <CODE>printOn:</CODE> method, and writes its output to the
supplied stream. The <CODE>printNl</CODE> method all objects use is simply
to send the current object a <CODE>printOn:</CODE> message whose argument
is "<CODE>stdout</CODE>". You can invoke the standard output stream
directly:
<PRE>
      'Hello, world' printOn: stdout !
      stdout inspect !
</PRE>

<A NAME="10.2.YourOwnStream"></A>
<H3>10.2.  Your Own Stream</H3>
<P>
     Unlike a pipe you might create  in  C,  the  underlying
storage  of  a <CODE>Stream</CODE> is under your control.  Thus, a
<CODE>Stream</CODE> 
can provide an anonymous buffer of data,  but  it  can  also
provide a stream-like interpretation to an existing array of
data.  Consider this example:
<PRE>
     Smalltalk at: #a put: (Array new: 10) !
     a at: 4 put: 1234 !
     a at: 9 put: 5678 !
     Smalltalk at: #s put: (ReadWriteStream on: a) !
     s inspect !
     s position: 1 !
     s inspect !
     s nextPut: 11; nextPut: 22 !
     (a at: 1) printNl !
     a do: [:x| x printNl] !
     s position: 2 !
     s do: [:x| x printNl] !
     s position: 5 !
     s do: [:x| x printNl] !
     s inspect !
</PRE>
<P>
     The key is the <CODE>on:</CODE> message; it tells a stream class  to
create  itself in terms of the existing storage.  Because of
polymorphism, the object specified by on: does not  have  to
be  an  <CODE>Array</CODE>; any object which responds to numeric
<CODE>at:</CODE> messages can be used.  If you happen to have  the
<CODE>CheckedArray</CODE> 
class  still loaded from the previous chapter, you might try
streaming over that kind of array instead.
<P>
     You're wondering if you're stuck with  having  to  know
how  much  data  will  be queued in a <CODE>Stream</CODE> at the time you
create the stream.  If you use the right  class  of  stream,
the answer is no.  A <CODE>ReadStream</CODE> provides read-only access to
an existing collection.  You will receive an  error  if  you
try  to  write to it.  If you try to read off the end of the
stream, you will also get an error.
<P>
     By contrast, <CODE>WriteStream</CODE> and <CODE>ReadWriteStream</CODE>
(used in our example) will tell the underlying collection to grow (using
the "<CODE>grow</CODE>" message) when you write off the end of the existing
collection. Thus, if you want to write several strings, and don't want to
add up their lengths yourself:
<PRE>
      Smalltalk at: #s put: (ReadWriteStream on: (String new: 0)) !
      s inspect !
      'Hello, ' printOn: s !
      s inspect !
      'world' printOn: s !
      s inspect !
      s position: 1 !
      s inspect !
      s do: [:c| c printOn: stdout] !
      (s contents) printNl !
</PRE>
<P>
     In this case, we have used a <CODE>String</CODE> as  the  collection
for the <CODE>Stream</CODE>.  The <CODE>printOn:</CODE> messages add bytes
to the initially empty string.  Once we've added  the  data,  you  can 
continue  to treat the data as a stream.  Alternatively, you
can ask the stream to return to you the  underlying  object.
After  that, you can use the object (a <CODE>String</CODE>, in this
example) using its own access methods. 
<P>
     There are many amenities available on a stream  object.
You  can  ask if there's more to read with "<CODE>atEnd</CODE>".  You can
query the position with "<CODE>position</CODE>", and set it  with
"<CODE>position:</CODE>".  You can see what will be read next with
"<CODE>peek</CODE>", and 
you can read the next element with "<CODE>next</CODE>".
<P>
     In the writing direction, you can write an element with
"<CODE>nextPut:</CODE>".   You  don't need to worry about objects doing a
<CODE>printOn:</CODE> with your stream as a destination;  this  operation
ends  up as a sequence of <CODE>nextPut:</CODE>'s to your stream.  If you
have  a  collection  of  things  to  write,  you   can   use
"<CODE>nextPutAll:</CODE>"  with the collection as an argument; each member
of the collection will be written onto the  stream.   If 
you want to write an object to the stream several times, you
can use "<CODE>next:put:</CODE>":
<PRE>
     Smalltalk at: #s put: (ReadWriteStream on: (Array new: 0)) !
     s next: 4 put: 'Hi!' !
     s position: 1 !
     s do: [:x| x printNl] !
</PRE>

<A NAME="10.3.Files"></A>
<H3>10.3.  Files</H3>
<P>
     Streams can also operate on files.  If  you  wanted  to
dump the file "<CODE>/etc/passwd</CODE>" to your terminal, you could create
a stream on the file, and then stream over its contents: 


<PRE>
     Smalltalk at: #f put: (FileStream open: '/etc/passwd' mode: 'r') !
     f do: [:c| c printOn: stdout] !
     f position: 30 !
     1 to: 25 do: [(f next) printOn: stdout] !
     f close !
</PRE>
and, of course, you can load Smalltalk source code:
<PRE>
     FileStream fileIn: '/users/myself/src/source.st' !
</PRE>

<A NAME="10.4.DynamicStrings"></A>
<H3>10.4.  Dynamic Strings</H3>
<P>
     Streams  provide a powerful abstraction for a number of
data structures.  Concepts like  current  position,  writing
the  next  position,  and  changing  the way you view a data
structure when convenient combine to let you write  compact,
powerful  code.   The  last example is taken from the actual
Smalltalk source code - it shows a general method  for  making
an object print itself onto a a string.
<PRE>
     printString
         | stream |
         stream := WriteStream on: (String new: 0).
         self printOn: stream.
         ^stream contents
     !
</PRE>
<P>
     This  method, residing in <CODE>Object</CODE>, is inherited by every
class in Smalltalk.  The first line  creates  a  <CODE>WriteStream</CODE>
which  stores  on  a <CODE>String</CODE> whose length is currently 0.  It
then invokes the  current  object  with  <CODE>printOn:</CODE>.   As  the
object prints itself to "<CODE>stream</CODE>", the <CODE>String</CODE>
grows to accommodate new characters.  When the object  is  done  printing, 
the method simply returns the underlying string.
<P>
     As  we've  written  code,  the assumption has been that
<CODE>printOn:</CODE> would go to the terminal.  But replacing  a  stream
to  a  file  (<CODE>/dev/tty</CODE>)  with  a  stream to a data structure
(<CODE>String new: 0</CODE>) works just as well.  The last line tells the
<CODE>Stream</CODE> to return its underlying collection - which will be the
string which has had all the  printing  added  to  it.   The
result  is that the <CODE>printString</CODE> message returns an object of
the <CODE>String</CODE> class whose contents are the printed
representation of the object receiving the <CODE>printString</CODE>
message. 


<A NAME="11.HowArraysWork"></A>
<H2>11.  How Arrays Work</H2>
<P>
     Smalltalk  provides a very adequate selection of predefined classes
from which to choose. Eventually, however, you will find the need to code a
new basic data structure. Because Smalltalk's most fundamental storage
allocation facilities are arrays, it is important that you understand how
to use them to gain efficient access to this kind of storage.

<A NAME="11.1.TheArrayClass"></A>
<H3>11.1.  The <CODE>Array</CODE> Class</H3>
<P>
     Our  examples  have  already shown the <CODE>Array</CODE> class, and
its use is fairly obvious.  For many applications,  it  will
fill  all  your needs - when you need an array in a new class,
you keep an instance variable,  allocate  a  new  Array  and
assign  it to the variable, and then send array accesses via
the instance variable.
<P>
     This technique  even  works  for  string-like  objects,
although  it is wasteful of storage.  An <CODE>Array</CODE> object uses a
<EM>Smalltalk pointer</EM> for each slot in the array; its exact size
is  transparent  to  the  programmer,  but you can generally
guess that it'll be roughly the word size of your machine<A
HREF="smalltalk-tutorial.html#note26">[26]</A><A name="ref26"></A></A>. 
For  storing  an  array  of  characters, therefore, an <CODE>Array</CODE>
works but is inefficient.

<A NAME="11.2.ArraysataLowerLevel"></A>
<H3>11.2.  Arrays at a Lower Level</H3>
<P>
     So let's step down to a lower level of data  structure.
a <CODE>ByteArray</CODE> is much like an <CODE>Array</CODE>, but each slot
holds only an integer from 0 to 255 - and each slot uses only a byte of
storage. If you only needed to store small quantities in each array slot,
this would therefore be a much more efficient choice than an
<CODE>Array</CODE>. As you might guess, this is the type of array which a
<CODE>String</CODE> uses.
<P>
     Aha!  But when you go back to chapter 9 and look at the
Smalltalk hierarchy, you notice that <CODE>String</CODE> does <EM>not</EM>
inherit 
from <CODE>ByteArray</CODE>.  To see why, we must delve down yet  another
level,  and  arrive  at  the  basic  methods for compiling a
class.
<P>
     For most example classes, we've used the message:
<PRE>
          subclass:
          instanceVariableNames:
          classVariableNames:
          poolDictionaries:
          category:
</PRE>
But when we implemented our <CODE>CheckedArray</CODE>  example,  we  used
"<CODE>variableSubclass:</CODE>" instead of just "<CODE>subclass:</CODE>".
The choice 
of these two kinds of class creation (and a third we'll show
shortly)  defines  the  fundamental  structure  of Smalltalk
objects created within a given class.   Let's  consider  the
differences in the next three sub-sections.

<A NAME="11.2.1.subclass:"></A>
<H4>11.2.1.  <CODE>subclass:</CODE></H4>
<P>
     This  kind  of  class  creation  specifies the simplest
Smalltalk object.  The object consists only of  the  storage
needed  to hold the instance variables.  In C, this would be
a simple structure with zero or more scalar fields<A
HREF="smalltalk-tutorial.html#note27">[27]</A><A name="ref27"></A></A>. 

<A NAME="11.2.2.variableSubclass:"></A>
<H4>11.2.2.  <CODE>variableSubclass:</CODE></H4>
<P>
     This type of class is a superset of a <CODE>subclass:</CODE>. Storage
is still allocated for any instance variables, but the objects of the class
must be created with a <CODE>new:</CODE> message. The number passed as an
argument to <CODE>new:</CODE> causes the new object, in addition to the
space for instance variables, to also have that many slots of storage
allocated. The analog in C would be to have a structure with some scalar
fields, followed at its end by an array of the requested size of pointers.

<A NAME="11.2.3.variableByteSubclass:"></A>
<H4>11.2.3.  <CODE>variableByteSubclass:</CODE></H4>
<P>
     This  is a special case of <CODE>variableSubclass:</CODE>; the storage
allocated as specified by <CODE>new:</CODE> is  an  array  of
<EM>bytes</EM>. 
The  analog  in  C  would be a structure with scalar fields,
followed by an array of <EM>char</EM>.

<A NAME="11.3.AccessingTheseNewArrays"></A>
<H3>11.3.  Accessing These New Arrays</H3>
<P>
     You already know how to  access  instance  variables - by
name.   But  there  doesn't  seem  to be a name for this new
storage.  The way an object accesses it is  to  send  itself
array-type messages - <CODE>at:</CODE>, <CODE>at:put:</CODE>, and so forth.
<P>
     The  problem is when an object wants to add a new level
of interpretation to the <CODE>at:</CODE> and <CODE>at:put:</CODE>
messages.  Consider 
a  <CODE>Dictionary</CODE> - it  is a <CODE>variableSubclass:</CODE> type
of object, but 
its <CODE>at:</CODE> message is in terms of a <EM>key</EM>, not an  integer
index 
of its storage.  Since it has redefined the <CODE>at:</CODE> message, how
does it access its fundamental storage?
<P>
     The answer is that Smalltalk has defined  <CODE>basicAt:</CODE>  and
<CODE>basicAt:put:</CODE>,  which will access the basic storage even when
the <CODE>at:</CODE> and <CODE>at:put:</CODE> messages have been defined to
provide  a 
different abstraction.

<A NAME="11.4.AnExample"></A>
<H3>11.4.  An Example</H3>
<P>
     This can get pretty confusing in the abstract, so let's
do an example to show how it's pretty  simple  in  practice.
Smalltalk  arrays  tend to start at 1; let's define an array
type whose permissible range is arbitrary.

<PRE>
     ArrayedCollection variableSubclass: 'RangedArray'
          instanceVariableNames: 'base'
          classVariableNames: ''
          poolDictionaries: ''
          category: nil !
     RangedArray comment: 'I am an Array whose base is arbitrary' !
     !RangedArray class methodsFor: 'creation'!
     new
          ^self error: 'Use new:base:'
     !
     new: ignore
          ^self new
     !
     new: size base: b
          ^(super new: size) init: b
     !!
     !RangedArray methodsFor: 'init'!
     init: b
          base := (b - 1).    "- 1 because basicAt: works with a 1 base"
          ^self
     !!
     !RangedArray methodsFor: 'basic'!
     rangeCheck: i
          ((i &lt;= base) | (i &gt; (base + (self basicSize)))) ifTrue: [
               'Bad index value: ' printOn: stderr.
               i printOn: stderr.
               (Character nl) printOn: stderr.
               ^self error: 'illegal index'
          ]
     !
     at: i
          self rangeCheck: i.
          ^self basicAt: (i-base)
     !
     at: i put: v
          self rangeCheck: i.
          ^self basicAt: (i-base) put: v
     !!
</PRE>
<P>
     The code has two parts; an initialization, which simply
records what index you wish the array to start with, and the
<CODE>at:</CODE> messages, which adjust the requested index so  that  the
underlying  storage  receives  its  1-based  index  instead.
We've included a range check  much  like  <CODE>CheckedArray</CODE>;  its
utility will demonstrate itself in a moment:
<PRE>
<P>
     Smalltalk at: #a put: (RangedArray new: 10 base: 5) !
     a at: 5 put: 0 !
     a at: 4 put: 1 !
</PRE>
Since  4 is below our base of 5, a range check error occurs.
But this check can catch more than just our own misbehavior!
<PRE>
     a do: [:x| x printNl] !
</PRE>
Our  <CODE>do:</CODE>  message  handling  is broken!  The stack backtrace
pretty much tells the story:


<PRE>
     RangedArray&gt;&gt;#rangeCheck:
     RangedArray&gt;&gt;#at:
     MethodContext&gt;&gt;#value:
     Integer&gt;&gt;#to:by:do:
     Integer&gt;&gt;#to:do:
     RangedArray&gt;&gt;#do:
</PRE>
Our code received a <CODE>do:</CODE> message.  We didn't define  one,  so
we  inherited  the  existing  <CODE>do:</CODE>  handling.  We see that an
<CODE>Integer</CODE> loop was constructed, that a code block was invoked,
and  that  our  own  <CODE>at:</CODE>  code  was  invoked.  When we range
checked, we trapped an illegal index.  Just by  coincidence,
this  version  of  our  range  checking  code also dumps the
index.  We see that <CODE>do:</CODE> has assumed that all arrays start at
1.
<P>
     The immediate fix is obvious; we implement our own <CODE>do:</CODE>
<PRE>
     !RangedArray methodsFor: 'basic'!
     do: aBlock
          1 to: (self basicSize) do: [:x|
               aBlock value: (self basicAt: x)
          ]
     !!
</PRE>
But  the  issues  start  to  run  deep.  If our parent class
believed that it knew enough to assume a starting  index  of
1,  why  didn't  it also assume that <EM>it</EM> could call
<CODE>basicAt:</CODE>? 
Object-oriented methodology says that one object  should  be
entirely opaque to another.  But what sort of privacy should
there be between a higher class  and  its  subclasses?   How
many  assumption  can  a subclass make about its superclass,
and how many  can  the  superclass  make  before  it  begins
infringing  on the sovereignty of its subclasses?  There are
rarely easy answers.

<A NAME="11.5.BasicAllocation"></A>
<H3>11.5.  Basic Allocation</H3>
<P>
     In this chapter, we've seen the fundamental mechanisms used to
allocate and index storage. When the storage need not be accessed with peak
efficiency, you can use the existing array classes. When every access
counts, having the storage be an integral part of your own object allows
for the quickest access. When you move into this area of object
development, inheritance and polymorphism become trickier; each level must
coordinate its use of the underlying array with other levels.


<A NAME="12.FurtherStudies"></A>
<H2>12.  Further Studies</H2>
<P>
     The question is always how far to go in one document. At this point,
you know how to create classes. You know how to use inheritance,
polymorphism, and the basic storage management mechanisms of Smalltalk.
You've also seen a sampling of Smalltalk's powerful classes. The rest of
this chapter simply points out areas for further study; perhaps a newer
version of this document might cover these in further chapters.

<A NAME="12.1.ViewingtheSmalltalkSourceCode"></A>
<H3>12.1.  Viewing the Smalltalk Source Code</H3>
<P>
     Depending   on  the  thoroughness  of  the  person  who
installed GNU Smalltalk, it's possible to  view  the  source
code  for  a system method.  For instance, to see how a
<CODE>Dictionary</CODE> processes a <CODE>do:</CODE> message: 
<PRE>
     Dictionary edit: #do: !
</PRE>
The viewer is hard-coded as emacs; this may or may not  work
at your installation.

<A NAME="12.2.OtherWaystoCollectObjects"></A>
<H3>12.2.  Other Ways to Collect Objects</H3>
<P>
     We've  seen  <CODE>Array</CODE>, <CODE>ByteArray</CODE>,
<CODE>Dictionary</CODE>, <CODE>Set</CODE>, and the 
various  streams.   You'll  want  to  look   at   the   <CODE>Bag</CODE>,
<CODE>LinkedList</CODE>,  and <CODE>SortedCollection</CODE> classes.  For
special purposes you'll want to examine <CODE>ByteMemory</CODE> and
<CODE>WordMemory</CODE>. 

<A NAME="12.3.FlowofControl"></A>
<H3>12.3.  Flow of Control</H3>
<P>
     GNU Smalltalk has rudimentary support  for  <EM>threads</EM>  of
execution.  The state is embodied in a <CODE>Process</CODE> class object;
you'll also want to look at the <CODE>ProcessorScheduler</CODE> class.

<A NAME="12.4.SmalltalkVirtualMachine"></A>
<H3>12.4.  Smalltalk Virtual Machine</H3>
<P>
     GNU Smalltalk is implemented as a  virtual  instruction
set.   By invoking GNU Smalltalk with the -d option, you can
view the byte opcodes which are generated as  files  on  the
command  line  are loaded.  Similarly, running GNU Smalltalk
with -e will trace the execution  of  instructions  in  your
methods.
<P>
     You  can  look at the GNU Smalltalk source to gain more
information on the instruction set. A better first step if you want to
pursue this subject is to start with "A Little Smalltalk" by Tim Budd. The
source code is freely available, and the book provides a solid introduction
to Smalltalk-type virtual machines. The canonical book is from the original
designers of Smalltalk:
<P>
     Smalltalk-80: The Language and its Implementation
          - Adele Goldberg and David Robson

<a name="Equality2">
<A NAME="12.5.TwoFlavorsofEquality"></A>
<H3>12.5.  Two Flavors of Equality</H3>
<P>
     As  first  seen in chapter two, Smalltalk keys its dictionary with
     things like "<CODE>#word</CODE>", whereas we  generally  use 
"<CODE>'word'</CODE>".   The  former, as it turns out, is from class
<CODE>Symbol</CODE>.  The latter is from class <CODE>String</CODE>.  What's
the real different  between  a <CODE>Symbol</CODE> and a
<CODE>String</CODE>?  To answer the question, we'll use an analogy from C. 


<P>
     In C, if you have a function for comparing strings, you
might try to write it:
<PRE>
     strcpy(char *p, char *q)
     {
          return (p == q);
     }
</PRE>
But  clearly this is wrong!  The reason is that you can have
two copies of a string - each with the same contents - but  each
at  its own address.  A correct string compare must walk its
way through the strings and compare each element.
<P>
     In Smalltalk, exactly the same issue  exists,  although
the  details  of  manipulating storage addresses are hidden.
If we have two Smalltalk strings, both with  the  same  contents,  we
don't  necessarily  know  if they're at the same 
storage address.  In  Smalltalk  terms,  we  don't  know  if
they're the <EM>same object</EM>.
<P>
     The  Smalltalk  dictionary  is searched frequently.  To
speed the search, it would be nice to not  have  to  compare
the characters of each element, but only compare the address
itself.  To do this, you need to have a guarantee  that  all
strings  with  the  same  contents are the same object.  The
String class, created like:
<PRE>
     y := 'Hello' !
</PRE>
does not satisfy this.  Each time you execute this line, you
may  well  get a new object.  But a very similar class,
<CODE>Symbol</CODE>, will always return the same object: 
<PRE>
     y := #Hello !
</PRE>
In general, you can use strings for almost all  your  tasks.
If  you  ever get into a performance-critical function which
looks up strings, you can switch to <CODE>Symbol</CODE>.  It takes longer
to  create  a  <CODE>Symbol</CODE>,  and the memory for a
<CODE>Symbol</CODE> is never 
freed (since the class has to keep tabs on  it  indefinitely
to  guarantee  it continues to return the same object).  You
can use it, but use it with care.
</a>

<a name="EqualityCheck">
<A NAME="12.6.CheckingfortheTwoTypesofEquality"></A>
<H3>12.6.  Checking for the Two Types of Equality</H3>
<P>
     This paper has generally used the strcmp()-ish kind  of
checks  for  equality.  If you ever need to ask the question
"is this the  same  object?",  you  use  the  "<CODE>==</CODE>"  operator
instead of "<CODE>=</CODE>":
<PRE>
     Smalltalk at: #x put: 0 !
     Smalltalk at: #y put: 0 !
     x := 'Hello' !
     y := 'Hello' !
     (x = y) printNl !
     (x == y) printNl !
     x := #Hello !
     y := #Hello !
     (x = y) printNl !
     (x == y) printNl !
</PRE>
<P>
     Using  C  terms, the former compares contents like
<CODE>strcmp()</CODE>. The latter compares storage addresses, like a
pointer comparison.
</a>

<A NAME="12.7.WheretogetHelp"></A>
<H3>12.7.  Where to get Help</H3>
<P>
     The  newsgroup comp.lang.smalltalk is read by many people with a great
deal of Smalltalk experience. There are several commercial Smalltalk
implementations; you can buy support for these, though it isn't cheap. For
the GNU Smalltalk system in particular, you can try the newsgroup
gnu.smalltalk.bug. If all else fails, you can try the author at:
<PRE>
     jtk@netcom.com
</PRE>
No guarantees, but the author will do his best!

<A NAME="12.8.Acknowledgments"></A>
<H3>12.8.  Acknowledgments</H3>
<P>
     Thanks  to Steve Byrne for writing GNU Smalltalk in the
first place.  Great thanks to Mark Bush  and  Bob  Roos  for
their meticulous jobs of proofreading this document, and the
generous amounts of input they provided  on  refinements  to
the  contents and structure.  Thanks also to Andrew Berg for
his comments on the early chapters of the document.
<P>
     Any remaining  errors  are  purely  the  fault  of  the
author.   This document is provided as-is, without warranty,
but I will happily accept reports of any  errors.   If  time
permits, I will perhaps even release a corrected revision of
the document.
<P>
     I release this document into  the  public  domain,  and
simply  request  that  you  acknowledge  me  as the original
author in any use or derivative work you make of this  document.




<PRE>
                         Andy Valencia
                         325 Union Ave #359
                         Campbell, CA  95008
                         jtk@netcom.com
                         November 27, 1992

</PRE>
<CENTER>
                         APPENDIX A
           A Simple Overview of Smalltalk Syntax
</CENTER>

<P>
     Smalltalk's  power comes from its treatment of objects.
In this document, we've mostly avoided the issue  of  syntax
by using strictly parenthesized expressions as needed.  When
this leads to code which is hard to read due to the  density
of  parentheses,   a knowledge of Smalltalk's syntax can let
you simplify expressions.  In general, if it  was  hard  for
you  to  tell how an expression would parse, it will be hard
for the next person, too.
<P>
     The following presentation presents the grammar a  couple  of  related
     elements at a time.  We use a BNF style of 
grammar, with some extensions.  The form:
<PRE>
     [ ... ]
</PRE>
means that "<CODE>...</CODE>" can occur zero or one times.
<PRE>
     [ ... ]*
</PRE>
means zero or more;
<PRE>
     [ ... ]+
</PRE>
means one or more.
<PRE>
      ... | ... [ | ... ]*
</PRE>
means that one of the variants must be  chosen.   Characters
in double quotes refer to the literal characters.  Most elements may be
separated by white space;  where  this  is  not 
legal,  the  elements  are  presented  without  white  space
between them.


<PRE>
     methods: "!" id ["class"] "methodsFor:" string "!" [method "!"] "!"
</PRE>
Methods are introduced by first naming a class (the <EM>id</EM>  element),
specifying  "<CODE>class</CODE>"  if  you're adding class methods 
instead of instance methods, and sending a  string  argument
to  the methodsFor: message.  Each method is terminated with
an "<CODE>!</CODE>"; two "<CODE>!</CODE>"'s in a row signify the end of the
new  methods. 

<PRE>
     method: message [prim] [temps] exprs
     message: id | binsel id | [keysel id]+
     prim: "&lt;" "primitive:" number "&gt;"
     temps: "|" [id]* "|"
</PRE>
A method definition starts out with a kind of template.  The
message to be handled is specified with  the  message  names
spelled  out  and  identifiers in the place of arguments.  A
special kind of definition is the <EM>primitive</EM>; it has not been
covered  in  this  paper;  it  provides  an interface to the
underlying Smalltalk virtual machine.  <EM>temps</EM> is the declaration
of  local variables.  Finally, <EM>exprs</EM> (covered soon) is 
the actual code for implementing the method.


<PRE>
     unit: id | literal | block | "(" expr ")"
     unaryexpr: unit [ id ]+
     primary: unit | unaryexpr
</PRE>
These are the "building blocks" of Smalltalk expressions.  A
<EM>unit</EM>  represents  a single Smalltalk value, with the highest
syntactic precedence.  A <EM>unaryexpr</EM> is simply  a  <EM>unit</EM>
which 
receives  a  number  of unary messages.  A <EM>unaryexpr</EM> has the
next highest precedence.  A <EM>primary</EM> is simply  a  convenient
left-hand-side name for one of the above.

<PRE>
     exprs: [expr "."]* [["^"] expr]
     expr: [id ":="]* expr2
     expr2: primary | msgexpr [ ";" cascade ]*
</PRE>
A  sequence of expressions is separated by "<CODE>.</CODE>"'s and can end
with a returned value ("<CODE>^</CODE>").  There can be  leading
assignments;  unlike  C, assignments apply only to simple variable 
names.  An expression is  either  a  primary  (with  highest
precedence)  or  a  more  complex message.  <EM>cascade</EM> does not
apply to <EM>primary</EM> constructions, as they are  too  simple  to
require  the  construct - since  all  <EM>primary</EM>  construct  are
unary, you can just add more unary messages:
<PRE>
     1234 printNl printNl printNl !
</PRE>

<PRE>
     msgexpr: unaryexpr | binexpr | keyexpr
</PRE>
A complex message is either a unary message (which  we  have
already covered), a binary message ("<CODE>+</CODE>", "<CODE>-</CODE>", and
so forth), 
or a keyword message ("<CODE>at:</CODE>", "<CODE>new:</CODE>", ....)
Unary  has  the 
highest precedence, followed by binary, and keyword messages
have the lowest precedence.  Examine the two versions of the
following  messages.   The second have had parentheses added
to show the default precedence.
<PRE>
     myvar at: 2 + 3 put: 4
     mybool ifTrue: [ ^ 2 / 4 roundup ]

     (myvar at: (2 + 3) put: (4))
     (mybool ifTrue: ([ ^ (2 / (4 roundup)) ]))

     cascade: id | binmsg | keymsg
</PRE>
A <EM>cascade</EM> is used to direct further  messages  to  the  same
object  which  was last used.  The three types of messages (<EM>id</EM> is
how you send a unary message) can thus be sent. 

<PRE>
     binexpr: primary binmsg [ binmsg ]*
     binmsg: binsel primary
     binsel: selchar[selchar]
</PRE>
A binary message is sent to an  object,  which  <EM>primary</EM>  has
identified.   Each binary message is a binary selector, constructed from
one or two characters, and an  argument  which 
is also provided by a examples<EM>primary</EM>.Some
<PRE>
     1 + 2 - 3 / 4
</PRE>
which parses as:
<PRE>
     (((1 + 2) - 3) / 4)
</PRE>


<PRE>
     keyexpr: keyexpr2 keymsg
     keyexpr2: binexpr | primary
     keymsg: [keysel keyw2]+
     keysel: id":"
</PRE>
Keyword expressions are much like binary expressions, except
that the selectors are made up of identifiers with  a  colon
appended.  Where the arguments to a binary function can only
be from <EM>primary</EM>, the arguments to a keyword  can  be  binary
expressions  or <EM>primary</EM> ones.  This is because keywords have
the lowest precedence.

<PRE>
     block: "[" [[":" id]* "|" ] exprs "]"
</PRE>
A code block is  square  brackets  around  a  collection  of
Smalltalk expressions.  The leading "<CODE>: id</CODE>" part is for block
arguments.

<PRE>
     literal: number | string | charconst | symconst | arrayconst
     arrayconst: "#" array
     array: "(" [number | string | symbol | array | charconst]* ")"
     number: [[dig]+ "r"] ["-"] [hexDig]+ ["." [hexDig]+] ["e"["-"][dig]+].
     string: "'"[char]*"'"
     charconst: "$"char
     symconst: "$"symbol
</PRE>
We have already shown the use of many  of  these  constants.
Although  not covered in this paper, numbers can have a base
specified at their front, and a  trailing  scientific  notation.   We have
seen examples of character, string, and symbol constants.  Array  constants
are  simple  enough;  they 
would look like:
<PRE>
     Smalltalk at: #a put: #(1 2 'Hi' $x $Hello 4 5) !
</PRE>

<PRE>
     symbol: id | binsel | keysel[keysel]*
</PRE>
Symbols  are  mostly used to represent the names of methods.
Thus, they can hold simple  identifiers,  binary  selectors,
and keyword selectors:
<PRE>
     $hello
     $+
     $at:put:
</PRE>

<PRE>
     id: letter[letter|dig]*
     selchar: "+" | "-" | "*" | "/" | "~" | "|" | "," |
          "&lt;" | "&gt;" | "=" | "&amp;"
     hexdig: "0".."9" | "A".."F"
     dig: "0".."9"
</PRE>
These are the categories of characters and how they are combined at the
most basic level.   <EM>selchar</EM>  simply  lists  the 
characters which can be combined to name a binary message.

<hr>
<h2>Notes</h2>
<P>
<A name="note1">
<A HREF="smalltalk-tutorial.html#ref1">[1]</A> It  also  prints  out  a  lot  of  statistics.
Ignore these; they provide information on the performance of the underlying
Smalltalk engine.   You 
can inhibit them by starting Smalltalk as:
<PRE>
     % mst -q
</PRE>
</A>
<hr>

<P>
<A name="note2">
<A HREF="smalltalk-tutorial.html#ref2">[2]</A> Which  table?   This is determined by the type
of the object.  An object has a type, known as the
<EM>class</EM> to which it belongs.  Each class has a table
of methods.  For the  object  we  created,  it  is
known as a member of the "<CODE>String</CODE>" class.  So we go
to the table associated with the <CODE>String</CODE> class.
</A>
<hr>

<P>
<A name="note3">
<A HREF="smalltalk-tutorial.html#ref3">[3]</A> Actually, the message "<CODE>printNl</CODE>" was
inherited 
from  <CODE>Object</CODE>.   It  sent  a  "<CODE>print</CODE>" message, also
inherited by <CODE>Object</CODE>, which then sent "<CODE>printOn:</CODE>" to
the  object, specifying that it print to "<CODE>stdout</CODE>".
The <CODE>String</CODE> class then prints its characters to the
standard output.
</A>
<hr>

<P>
<A name="note4">
<A HREF="smalltalk-tutorial.html#ref4">[4]</A> Alert  readers  will  remember  that  the math
examples of the  previous  chapter  deviated  from
this.
</A>
<hr>

<P>
<A name="note5">
<A HREF="smalltalk-tutorial.html#ref5">[5]</A> As of release  1.1,  GNU  Smalltalk  does  not
actually catch this error.
</A>
<hr>

<P>
<A name="note6">
<A HREF="smalltalk-tutorial.html#ref6">[6]</A> This is known as "garbage collection."  It  is
generally  done  when  Smalltalk  finds that it is
running low on memory.
</A>
<hr>

<P>
<A name="note7">
<A HREF="smalltalk-tutorial.html#ref7">[7]</A> Actually,  a <CODE>SystemDictionary</CODE>, which
is just a 
<CODE>Dictionary</CODE> with some extra  hooks  to  run  things
when Smalltalk first starts
</A>
<hr>

<P>
<A name="note8">
<A HREF="smalltalk-tutorial.html#ref8">[8]</A> For more detail, please feel free to skip out to
chapter 12 and read the section <a href="smalltalk-tutorial.html#Equality2">"Two Flavors of
Equality"</a> and the following section <a href="smalltalk-tutorial.html#EqualityCheck">"Checking
for the Two Types of Equality."</a>
</A>
<hr>

<P>
<A name="note9">
<A HREF="smalltalk-tutorial.html#ref9">[9]</A> In  case  you're having a hard time making out
the font, the "<CODE>''</CODE>"'s after <CODE>classVariableNames:</CODE> and
<CODE>poolDictionaries:</CODE>  are  a pair of single quotes - an
empty string.
</A>
<hr>

<P>
<A name="note10">
<A HREF="smalltalk-tutorial.html#ref10">[10]</A> And unlike C, Smalltalk draws a distinction
between 0 and nil. nil is the "nothing" object, and you will receive an
error if you try to do, say, math on it. It really does matter that we
initialize our instance variable to the number 0 if we wish to do math on
it in the future.
</A>
<hr>

<P>
<A name="note11">
<A HREF="smalltalk-tutorial.html#ref11">[11]</A> And  why  didn't  the  designers  default the
return value to <CODE>nil</CODE>?  Perhaps they didn't appreciate  the
value  of void functions.  After all, at 
the time Smalltalk was being  designed,  C  didn't
even have a void data type.
</A>
<hr>

<P>
<A name="note12">
<A HREF="smalltalk-tutorial.html#ref12">[12]</A> "<CODE>self</CODE>"  is  much  like
"<CODE>super</CODE>",  except that 
"<CODE>self</CODE>" will start looking for a method at the bottom  of  the
type  hierarchy  for the object, but 
"<CODE>super</CODE>" starts looking one level <EM>up</EM> from the  current
level.   Thus,  using "<CODE>super</CODE>" <EM>forces</EM> inheritance, but
"<CODE>self</CODE>" will find the  first  definition 
of the message which it can.
</A>
<hr>

<P>
<A name="note13">
<A HREF="smalltalk-tutorial.html#ref13">[13]</A> Of course, in a  real  accounting  system  we
would never discard such information - we'd probably
throw it into a Dictionary object, indexed by  the
year  that  we're  finishing.  The ambitious might
want to try their hand  at  implementing  such  an
enhancement.
</A>
<hr>

<P>
<A name="note14">
<A HREF="smalltalk-tutorial.html#ref14">[14]</A> It is interesting to note that because of the
way  conditionals are done, conditional constructs
are not part of the  Smalltalk  language - they  are
merely a defined behavior for the Boolean class of
objects.
</A>
<hr>

<P>
<A name="note15">
<A HREF="smalltalk-tutorial.html#ref15">[15]</A> This  is  the  case  in GNU Smalltalk.  Other
implementations will refuse to redefine the  class

until  <EM>all</EM>  of its instances have been hunted down
and eradicated!
</A>
<hr>

<P>
<A name="note16">
<A HREF="smalltalk-tutorial.html#ref16">[16]</A> Technically, GNU Smalltalk has associated  us
with  the  existing  <EM>class</EM> methods, but with a new
set of <EM>instance</EM> methods.  It is often  simpler  to
work  as  if  you had to define everything, rather
than trying to take advantage of this.
</A>
<hr>

<P>
<A name="note17">
<A HREF="smalltalk-tutorial.html#ref17">[17]</A> You might start to wonder what one would do if
you wished to associate <EM>two</EM> pieces of information under one key.
Say, the value and who the check was written to. There are several ways;
the best would probably be to create a new, custom object which contained
this information, and then store this object under the check number key in
the dictionary. It would also be valid (though probably over-kill) to store
a dictionary as the value - and then store as many pieces of information as
you'd like under each slot!
</A>
<hr>

<P>
<A name="note18">
<A HREF="smalltalk-tutorial.html#ref18">[18]</A> The <CODE>do:</CODE> message is understood by
most types of Smalltalk collections. It works for the
<CODE>Dictionary</CODE> class, as well as sets, arrays, strings, intervals,
linked lists, bags, and streams. The <CODE>associationsDo:</CODE> message
works only with dictionaries. The difference is that <CODE>do:</CODE>
passes only the <EM>value</EM> portion, while <CODE>associationsDo:</CODE>
passes the entire <EM>key/value</EM> pair in an <CODE>Association</CODE>
object.
</A>
<hr>

<P>
<A name="note19">
<A HREF="smalltalk-tutorial.html#ref19">[19]</A> There is also a  <CODE>valueWithArguments:</CODE>
message 
which  accepts  an array holding as many arguments
as you would like.
</A>
<hr>

<P>
<A name="note20">
<A HREF="smalltalk-tutorial.html#ref20">[20]</A> And in fact, you <EM>will</EM>  receive  an
error  in 
most Smalltalk systems.
</A>
<hr>


<P>
<A name="note21">
<A HREF="smalltalk-tutorial.html#ref21">[21]</A> Again,  it <EM>will</EM> error in most other
Smalltalk 
implementations.
</A>
<hr>

<P>
<A name="note22">
<A HREF="smalltalk-tutorial.html#ref22">[22]</A> This listing is courtesy of the
<CODE>printHierarchy</CODE>  method supplied by GNU Smalltalk author Steve 
Byrne.  If you have the GNU Smalltalk source, it's
in the <CODE>samples/</CODE> directory.
</A>
<hr>

<P>
<A name="note23">
<A HREF="smalltalk-tutorial.html#ref23">[23]</A> Ignore  <CODE>LookupKey;</CODE> its presence
appears to be 
historical.
</A>
<hr>

<P>
<A name="note24">
<A HREF="smalltalk-tutorial.html#ref24">[24]</A> Smalltalk also offers an "<CODE>or:</CODE>"
message, which is different in a subtle way from "<CODE>|</CODE>". or:
takes a code block, and only invokes the code block if it's necessary to
determine the value of the expression. This is analogous to the guaranteed
C semantic that "<CODE>&amp;&amp;</CODE>" evaluates left-to-right only as
far as needed. We could have written the expressions as "<CODE>((index &lt;
1) or: [index &gt; (self basicSize)])</CODE>". Since we expect both sides
of or: to be false most of the time, there isn't much reason to delay
evaluation of either side.
</A>
<hr>

<P>
<A name="note25">
<A HREF="smalltalk-tutorial.html#ref25">[25]</A> Hint: consider what the default return  value
is  when  no explicit value is provided.  This was
covered in chapter 4.
</A>
<hr>

<P>
<A name="note26">
<A HREF="smalltalk-tutorial.html#ref26">[26]</A> 32 bits for most ports of GNU Smalltalk.
</A>
<hr>

 <P>
<A name="note27">
<A HREF="smalltalk-tutorial.html#ref27">[27]</A> C requires one or more; zero  is  allowed  in
Smalltalk.
</A>

<hr>
<address></address>
<!-- hhmts start -->
Last modified: Thu Feb 15 16:57:10 MET 1996
<!-- hhmts end -->
</body> </html>
